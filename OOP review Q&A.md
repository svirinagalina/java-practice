# Вопросы по Java

## Содержание
1. [Что такое ООП? В чем его плюсы](#what-is-oop)
2. [Перечислите основные принципы ООП](#перечислите-основные-принципы-ооп)
3. [Что такое инкапсуляция? Приведите пример инкапсуляции](#что-такое-инкапсуляция-приведите-пример-инкапсуляции)
4. [Что такое полиморфизм? Приведите пример полиморфизма](#что-такое-полиморфизм-приведите-пример-полиморфизма)
5. [Что такое наследование? Приведите пример наследования? Зачем оно нужно?](#что-такое-наследование-приведите-пример-наследования-зачем-оно-нужно)
6. [Что такое класс? Объект?](#что-такое-класс-объект)
7. [Как передаются объекты в метод?](#как-передаются-объекты-в-метод)
8. [Что такое переопределение метода в Java?](#что-такое-переопределение-метода-в-java)
9. [Что такое перегрузка метода в Java?](#что-такое-перегрузка-метода-в-java)
10. [Что такое нативные методы, их плюсы и минусы?](#что-такое-нативные-методы-их-плюсы-и-минусы)
11. [Что такое метод, возвращаемое значение, аргументы метода](#что-такое-метод-возвращаемое-значение-аргументы-метода)
12. [Какие модификаторы доступа могут быть у класса](#какие-модификаторы-доступа-могут-быть-у-класса)
13. [Что такое final? Что может быть final? Как они работают?](#что-такое-final-что-может-быть-final-как-они-работают)
14. [Как реализована неизменность String](#как-реализована-неизменность-string)
15. [Как реализовать свой Immutable тип данных](#как-реализовать-свой-immutable-тип-данных)
16. [Что такое ключевое слово static? Что может быть static?](#что-такое-ключевое-слово-static-что-может-быть-static)
17. [Могут ли нестатические методы перегрузить статические?](#могут-ли-нестатические-методы-перегрузить-статические)
18. [Что такое пакет? Как создать пакет?](#что-такое-пакет-как-создать-пакет)
19. [Что такое конструкторы? Конструктор по-умолчанию?](#что-такое-конструкторы-конструктор-по-умолчанию)
20. [Что такое this и super? Когда мы обязаны их использовать?](#что-такое-this-и-super-когда-мы-обязаны-их-использовать)
21. [Класс Object и все методы кроме wait, notify, notifyAll](#класс-object-и-все-методы-кроме-wait-notify-notifyall)
22. [Зачем нужен метод finalize](#зачем-нужен-метод-finalize)
23. [Из-за чего происходят коллизии](#из-за-чего-происходят-коллизии)
24. [В чём разница между instanceof и getClass](#в-чём-разница-между-instanceof-и-getclass)
25. [Перечислите методы именно класса Enum](#перечислите-методы-именно-класса-enum)
26. [Что такое интерфейс? Когда использовать интерфейс?](#что-такое-интерфейс-когда-использовать-интерфейс)
27. [Можно ли создать поля в интерфейсе](#можно-ли-создать-поля-в-интерфейсе)
28. [Есть ли в Java множественное наследование? Зачем реализовывать интерфейс интерфейсу?](#есть-ли-в-java-множественное-наследование-зачем-реализовывать-интерфейс-интерфейсу)
29. [Можно ли создавать static методы в интерфейсах](#можно-ли-создавать-static-методы-в-интерфейсах)
30. [Что такое абстрактный метод](#что-такое-абстрактный-метод)
31. [Что такое абстрактный класс? Чем отличается от обычного?](#что-такое-абстрактный-класс-чем-отличается-от-обычного)
32. [Может ли быть конструктор у абстрактного класса](#может-ли-быть-конструктор-у-абстрактного-класса)
33. [Будет ли в классе конструктор, если его не задали?](#будет-ли-в-классе-конструктор-если-его-не-задали)
34. [Зачем this в конструкторе абстрактного класса](#зачем-this-в-конструкторе-абстрактного-класса)
35. [Будет ли создан автоматически конструктор по умолчанию, если есть другой?](#будет-ли-создан-автоматически-конструктор-по-умолчанию-если-есть-другой)
36. [Можно ли вызвать один конструктор из другого?](#можно-ли-вызвать-один-конструктор-из-другого)
37. [Синтаксические отличия интерфейса от абстрактного класса](#синтаксические-отличия-интерфейса-от-абстрактного-класса)
38. [Какие методы в интерфейсе могут иметь реализацию](#какие-методы-в-интерфейсе-могут-иметь-реализацию)
39. [Сколько максимум можно имплементировать интерфейсов](#сколько-максимум-можно-имплементировать-интерфейсов)
40. [Что такое интерфейс? Когда использовать интерфейс?](#что-такое-интерфейс-когда-использовать-интерфейс-1)
41. [Какие модификаторы доступа можно использовать в интерфейсе и абстрактном классе](#какие-модификаторы-доступа-можно-использовать-в-интерфейсе-и-абстрактном-классе)
42. [Как написать валидный код с интерфейсом, не реализуя методы](#как-написать-валидный-код-с-интерфейсом-не-реализуя-методы)
43. [Может ли быть абстрактный класс без абстрактных методов](#может-ли-быть-абстрактный-класс-без-абстрактных-методов)
44. [Как сделать из обычного класса абстрактный без abstract](#как-сделать-из-обычного-класса-абстрактный-без-abstract)
45. [Может ли Enum имплементировать интерфейсы](#может-ли-enum-имплементировать-интерфейсы)
46. [Может ли Enum наследовать класс? Почему?](#может-ли-enum-наследовать-класс-почему)
47. [Контракт между equals и hashCode](#контракт-между-equals-и-hashcode)
48. [Почему происходят коллизии hashCode](#почему-происходят-коллизии-hashcode)
49. [Какой тип данных у hashCode? Может ли быть отрицательным?](#какой-тип-данных-у-hashcode-может-ли-быть-отрицательным)
50. [Что такое наследование, композиция, агрегирование](#что-такое-наследование-композиция-агрегирование)



## Что такое ООП? В чем его плюсы
(Твой ответ)

## Перечислите основные принципы ООП
(Твой ответ)

## Что такое метод, возвращаемое значение, аргументы метода

Метод — это именованный блок кода внутри класса, который описывает действие (поведение) объекта или класса.
 Метод можно вызывать многократно, передав ему данные (аргументы) и получая результат (возвращаемое значение).

 Возвращаемое значение метода
Тип данных, который метод отдаёт после выполнения.


Если метод ничего не возвращает, указывается void.
Аргументы метода (параметры)
Входные данные, которые передаются в метод.


Перечисляются в круглых скобках после имени метода.


Могут быть ноль, один или несколько.

модификатор_доступа [доп. модификаторы] тип_возвращаемого_значения имяМетода(параметры) {
    // тело метода
}

 Пример полного класса с методами
public class Calculator {
    // метод с возвращаемым значением
    public int sum(int a, int b) {
        return a + b;
    }

    // метод без возвращаемого значения (void)
    public void printHello() {
        System.out.println("Hello!");
    }
}


Итого:
Метод = поведение объекта/класса.


Возвращаемое значение = результат работы метода (или void, если ничего не возвращает).


Аргументы = данные, которые мы передаём в метод для работы.

## Какие модификаторы доступа могут быть у класса

Модификаторы доступа у класса в Java
Нужно различать: топ-уровневый класс (обычный, в отдельном .java файле) и вложенный (inner/nested) класс.

Для топ-уровневого класса:
public → доступен из любого пакета.


(default) package-private (если не указать модификатор) → доступен только внутри своего пакета.


Других модификаторов (private, protected) у топ-классов быть не может.

Для вложенных классов (inner classes):

Могут быть все варианты:
public → доступен везде.


protected → доступен в своём пакете + наследникам.


private → доступен только внутри своего класса.

package-private - доступен только внутри своего пакета.

## Что такое final? Что может быть final? Как они работают?

✅ Что такое final в Java?
Ключевое слово final используется, чтобы запретить изменение чего-либо: переменной, метода или класса.
 Значение зависит от того, к чему применено.

🔹 1. final переменная
Её значение можно присвоить только один раз.

После инициализации изменить нельзя.

🔹 2. final поля класса
Должны быть инициализированы сразу или в конструкторе.


🔹 3. final метод
Такой метод нельзя переопределить в наследниках.
🔹 4. final класс
Такой класс нельзя наследовать.


Пример: String, Integer, Math в стандартной библиотеке Java.

📌 Итог

final переменная → значение не меняется после создания.


final поле → фиксируется при создании объекта. может быть разной у разных объектов.


final метод → не может быть переопределене.


final класс → нельзя наследовать.

## Как реализована неизменность String

✅ Как реализована неизменность String в Java
Класс String в Java является immutable (неизменяемым).
 Это значит: после создания объекта изменить его содержимое уже нельзя.

🔹 Как это реализовано внутри:
Поле хранения символов объявлено private final:

 private final char[] value;   // (в старых версиях)
// или
private final byte[] value;   // (в новых версиях Java для экономии памяти)
 👉 final означает, что ссылка всегда указывает на один и тот же массив.


Нет методов, изменяющих массив напрямую.
 Любая операция (например, concat, replace, substring) возвращает новый объект String, а не меняет старый.


Пул строк (String Pool).
 Благодаря неизменности возможна оптимизация — ссылки на одинаковые строковые литералы указывают на один объект в пуле.


Безопасность.
 Поскольку строка не меняется, её можно безопасно использовать как ключ в HashMap или передавать между потоками.

👉 Благодаря этому строки:
можно кэшировать,


безопасно использовать в многопоточности,


применять как ключи в коллекциях.

## Как реализовать свой Immutable тип данных

Короткая схема (чек-лист):
Сделайте класс final (чтобы его нельзя было расширить и «сломать» неизменность через наследование).


Все поля — private final.


Инициализация только в конструкторе (или через билдера, который в конце создаёт объект).


Никаких сеттеров. Методы, «изменяющие» состояние, должны возвращать новый объект.


Для изменяемых полей (массивы, коллекции, Date, любые мутируемые типы) — делайте defensive copy:


копируйте входящие аргументы в конструкторе;


при геттерах возвращайте копию/неизменяемое представление.


Продумайте корректные equals, hashCode, toString.


## Что такое ключевое слово static? Что может быть static?

✅ Ключевое слово static в Java
Ключевое слово static означает, что элемент класса (переменная, метод, блок или вложенный класс) принадлежит самому классу, а не его объектам.

📌 То есть:
Статический член создаётся один раз в памяти при загрузке класса.

Доступ к нему идёт через имя класса, а не через объект.

🔹 Что может быть static?
Статические поля (переменные класса)

Общие для всех объектов.

class Counter {
    static int count = 0; // общее поле для всех
    Counter() { count++; }
}

Статические методы

Можно вызвать без создания объекта.

Не имеют доступа к нестатическим полям/методам (потому что они принадлежат объекту).

class MathUtils {
    static int square(int x) {
        return x * x;
    }
}
// вызов:
int s = MathUtils.square(5);

Статический блок инициализации

Выполняется один раз при загрузке класса.

class Example {
    static int value;
    static {
        value = 42; // выполняется один раз при загрузке класса
    }
}
Статические вложенные классы

Не хранят ссылку на внешний объект.

class Outer {
    static class Inner {
        void print() { System.out.println("Hello from static nested class"); }
    }
}

Статический импорт

Позволяет обращаться к статическим полям/методам без имени класса.


import static java.lang.Math.*; 
double r = sqrt(25); // вместо Math.sqrt(25)


📌 Итог:
static = "принадлежит классу, а не объекту".


Может применяться к: полям, методам, блокам инициализации, вложенным классам, а также через static import.


 ## Могут ли нестатические методы перегрузить статические?

✅ Могут ли нестатические методы перегрузить статические?
Да, перегрузка (overloading) возможна между статическими и нестатическими методами, потому что перегрузка в Java определяется только сигнатурой метода (имя + параметры).

 Тип метода (static или нет) на перегрузку не влияет.
❌ Но!
Переопределить (override) статический метод нельзя, потому что статические методы принадлежат классу, а не объекту.
 В наследниках можно только скрыть (method hiding) статический метод, если объявить с такой же сигнатурой.

📌 Итог:
Перегрузка: да, возможна (static ↔ non-static).


Переопределение: нет, статические методы не переопределяются.


 ## Что такое пакет? Как создать пакет?

Что такое пакет (package) в Java?
Пакет — это способ организации классов и интерфейсов в группы.
 Можно думать о пакете как о «папке» в файловой системе, которая помогает:
структурировать проект,


избежать конфликтов имён (два класса с одинаковым именем могут жить в разных пакетах),


управлять доступом (модификатор default = доступ только внутри пакета).
В начале .java файла указываем пакет:

 package mypackage;

Файл нужно положить в соответствующую папку:


mypackage/Person.java


В другом классе подключаем через import:

 import mypackage.Person;

public class Main {
    public static void main(String[] args) {
        Person p = new Person();
    }
}
📌 Итог:
Пакет = «пространство имён + папка».


Создаётся через ключевое слово package и соответствующую структуру папок.

## Что такое конструкторы? Конструктор по-умолчанию?

✅ Что такое конструкторы?
Конструктор — это специальный метод в классе, который вызывается при создании объекта.
 Его задача — инициализировать поля объекта.
📌 Отличия от обычного метода:
имя конструктора совпадает с именем класса,


не имеет возвращаемого типа (даже void нельзя указывать),


вызывается автоматически при создании объекта через new.


✅ Конструктор по умолчанию
Если в классе не объявлен ни один конструктор, компилятор автоматически добавляет пустой конструктор без параметров.
📌 Но! Если вы написали хотя бы один конструктор (например, с параметрами) → конструктор по умолчанию уже не создаётся. Если он нужен, его придётся написать явно.

## [Что такое this и super? Когда мы обязаны их использовать?

🔹  this — это ссылка на текущий объект.
 Используется:
Чтобы отличить поле класса от параметра метода или конструктора.


Чтобы вызвать другой конструктор внутри того же класса. (Такой вызов всегда должен быть первой строкой конструктора.)



🔹 super
super — это ссылка на родительский (суперкласс).
 Используется:
Чтобы вызвать конструктор родительского класса. (Обязательно первой строкой конструктора наследника, если у родителя нет конструктора по умолчанию.)


Чтобы обратиться к методам или полям родителя, если они перекрыты в наследнике.



👉 Итого:
this → «мой объект».


super → «мой родитель».

## Класс Object и все методы кроме wait, notify, notifyAll

Object — родитель всех классов в Java. Методы:

toString() — строковое представление объекта.

equals(Object o) — сравнение объектов по содержимому.

hashCode() — числовой код для быстрого сравнения, нужен для HashMap, HashSet.

clone() — создаёт копию объекта (поверхностную).

getClass() — возвращает класс объекта (runtime).

finalize() — вызывается перед удалением объекта сборщиком мусора (deprecated).

## Зачем нужен метод finalize

Использовался для освобождения ресурсов (файлы, сокеты) перед удалением объекта.

Сейчас deprecated: лучше использовать try-with-resources и интерфейс AutoCloseable.

## Из-за чего происходят коллизии

Коллизии происходят, когда два или более объекта (или данных) имеют одинаковый хеш-код. 
Причины возникновения коллизий:
Ограниченность диапазона хеш-кодов:


## Разница между instanceOf() и getClass() 

instanceof — проверяет, является ли объект экземпляром класса или его наследника.

getClass() — возвращает точный класс объекта → без учёта наследования.

## Методы класса Enum

values() — возвращает массив всех констант перечисления.

valueOf(String name) — возвращает константу по имени.

ordinal() — позиция константы (с 0).

name() — имя константы.

compareTo(E o) — сравнивает порядок констант.

## Что такое интерфейс. Когда использовать интерфейс

Интерфейс = контракт (набор абстрактных методов), который класс обязан реализовать.

Используем, когда хотим задать поведение без реализации (например, Comparable, Runnable).

## Можно ли создать поля в интерфейсе

Да, но только public static final (константы).

Обычных переменных состояния быть не может.

## Есть ли в Java множественное наследование? Зачем реализовывать интерфейс интерфейсу?

Множественное наследование классов → ❌ нет.

Множественное наследование интерфейсов → ✔ есть (и именно это заменяет множественное наследование в Java). Это безопасно, потому что интерфейсы не содержат состояния (полей, которые можно менять).

Интерфейс может «реализовать» (точнее, расширять) другой интерфейс, чтобы создать более сложный контракт из простых частей. Это удобно для архитектуры и избавляет от дублирования.

## Можно ли создавать статик-методы в интерфейсах

Да, начиная с Java 8.

Вызываются через имя интерфейса (InterfaceName.method()

## Что такое абстрактный метод

Метод без реализации (тело отсутствует).

Определяется в abstract классе или интерфейсе.

Реализация обязана быть в подклассе/классе-реализаторе.

## Что такое абстрактный класс 

Абстрактный класс — это класс, который не может быть использован для создания экземпляров (то есть, вы не можете создать объект этого класса). Он используется как "шаблон" для других классов. В абстрактном классе могут быть как абстрактные методы (методы без реализации), так и обычные методы с реализацией. Основная цель абстрактных классов — предоставить общую основу для других классов, а также обязать их реализовать определённые методы.
не может быть инстанцирован
может содержать как абстрактные так и обычные методы 
может содержать поля и конструкторы

## 
