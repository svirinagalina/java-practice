# Вопросы по Java

## Содержание
1. [Что такое ООП? В чем его плюсы](#что-такое-ООП-В-чем-его-плюсы)
2. [Перечислите основные принципы ООП](#перечислите-основные-принципы-ооп)
3. [Что такое инкапсуляция? Приведите пример инкапсуляции](#что-такое-инкапсуляция-приведите-пример-инкапсуляции)
4. [Что такое полиморфизм? Приведите пример полиморфизма](#что-такое-полиморфизм-приведите-пример-полиморфизма)
5. [Что такое наследование? Приведите пример наследования? Зачем оно нужно?](#что-такое-наследование-приведите-пример-наследования-зачем-оно-нужно)
6. [Что такое класс? Объект?](#что-такое-класс-объект)
7. [Как передаются объекты в метод?](#как-передаются-объекты-в-метод)
8. [Что такое переопределение метода в Java?](#что-такое-переопределение-метода-в-java)
9. [Что такое перегрузка метода в Java?](#что-такое-перегрузка-метода-в-java)
10. [Что такое нативные методы, их плюсы и минусы?](#что-такое-нативные-методы-их-плюсы-и-минусы)
11. [Что такое метод, возвращаемое значение, аргументы метода](#что-такое-метод-возвращаемое-значение-аргументы-метода)
12. [Какие модификаторы доступа могут быть у класса](#какие-модификаторы-доступа-могут-быть-у-класса)
13. [Что такое final? Что может быть final? Как они работают?](#что-такое-final-что-может-быть-final-как-они-работают)
14. [Как реализована неизменность String](#как-реализована-неизменность-string)
15. [Как реализовать свой Immutable тип данных](#как-реализовать-свой-immutable-тип-данных)
16. [Что такое ключевое слово static? Что может быть static?](#что-такое-ключевое-слово-static-что-может-быть-static)
17. [Могут ли нестатические методы перегрузить статические?](#могут-ли-нестатические-методы-перегрузить-статические)
18. [Что такое пакет? Как создать пакет?](#что-такое-пакет-как-создать-пакет)
19. [Что такое конструкторы? Конструктор по-умолчанию?](#что-такое-конструкторы-конструктор-по-умолчанию)
20. [Что такое this и super? Когда мы обязаны их использовать?](#что-такое-this-и-super-когда-мы-обязаны-их-использовать)
21. [Класс Object и все методы кроме wait, notify, notifyAll](#класс-object-и-все-методы-кроме-wait-notify-notifyall)
22. [Зачем нужен метод finalize](#зачем-нужен-метод-finalize)
23. [Из-за чего происходят коллизии](#из-за-чего-происходят-коллизии)
24. [В чём разница между instanceof и getClass](#в-чём-разница-между-instanceof-и-getclass)
25. [Перечислите методы именно класса Enum](#перечислите-методы-именно-класса-enum)
26. [Что такое интерфейс? Когда использовать интерфейс?](#что-такое-интерфейс-когда-использовать-интерфейс)
27. [Можно ли создать поля в интерфейсе](#можно-ли-создать-поля-в-интерфейсе)
28. [Есть ли в Java множественное наследование? Зачем реализовывать интерфейс интерфейсу?](#есть-ли-в-java-множественное-наследование-зачем-реализовывать-интерфейс-интерфейсу)
29. [Можно ли создавать static методы в интерфейсах](#можно-ли-создавать-static-методы-в-интерфейсах)
30. [Что такое абстрактный метод](#что-такое-абстрактный-метод)
31. [Что такое абстрактный класс? Чем отличается от обычного?](#что-такое-абстрактный-класс-чем-отличается-от-обычного)
32. [Может ли быть конструктор у абстрактного класса](#может-ли-быть-конструктор-у-абстрактного-класса)
33. [Будет ли в классе конструктор, если его не задали?](#будет-ли-в-классе-конструктор-если-его-не-задали)
34. [Зачем this в конструкторе абстрактного класса](#зачем-this-в-конструкторе-абстрактного-класса)
35. [Будет ли создан автоматически конструктор по умолчанию, если есть другой?](#будет-ли-создан-автоматически-конструктор-по-умолчанию-если-есть-другой)
36. [Можно ли вызвать один конструктор из другого?](#можно-ли-вызвать-один-конструктор-из-другого)
37. [Синтаксические отличия интерфейса от абстрактного класса](#синтаксические-отличия-интерфейса-от-абстрактного-класса)
38. [Какие методы в интерфейсе могут иметь реализацию](#какие-методы-в-интерфейсе-могут-иметь-реализацию)
39. [Сколько максимум можно имплементировать интерфейсов](#сколько-максимум-можно-имплементировать-интерфейсов)
40. [Что такое интерфейс? Когда использовать интерфейс?](#что-такое-интерфейс-когда-использовать-интерфейс-1)
41. [Какие модификаторы доступа можно использовать в интерфейсе и абстрактном классе](#какие-модификаторы-доступа-можно-использовать-в-интерфейсе-и-абстрактном-классе)
42. [Как написать валидный код с интерфейсом, не реализуя методы](#как-написать-валидный-код-с-интерфейсом-не-реализуя-методы)
43. [Может ли быть абстрактный класс без абстрактных методов](#может-ли-быть-абстрактный-класс-без-абстрактных-методов)
44. [Как сделать из обычного класса абстрактный без abstract](#как-сделать-из-обычного-класса-абстрактный-без-abstract)
45. [Может ли Enum имплементировать интерфейсы](#может-ли-enum-имплементировать-интерфейсы)
46. [Может ли Enum наследовать класс? Почему?](#может-ли-enum-наследовать-класс-почему)
47. [Контракт между equals и hashCode](#контракт-между-equals-и-hashcode)
48. [Почему происходят коллизии hashCode](#почему-происходят-коллизии-hashcode)
49. [Какой тип данных у hashCode? Может ли быть отрицательным?](#какой-тип-данных-у-hashcode-может-ли-быть-отрицательным)
50. [Что такое наследование, композиция, агрегирование](#что-такое-наследование-композиция-агрегирование)
51. [Что можно делать при переопределении метода, а что нельзя](#что-можно-делать-при-переопределении-метода-а-что-нельзя)  
52. [Ковариантность типа возвращаемого значения](#ковариантность-типа-возвращаемого-значения)  
53. [Что будет если передать массив в метод, который изменит его значения изменятся ли они вне метода почему а если передать примитив](#что-будет-если-передать-массив-в-метод-который-изменит-его-значения-изменятся-ли-они-вне-метода-почему-а-если-передать-примитив)  
54. [Передача параметров в методы По значению по ссылке Как передаются примитивы и объекты](#передача-параметров-в-методы-по-значению-по-ссылке-как-передаются-примитивы-и-объекты)  
55. [Что такое контракт метода](#что-такое-контракт-метода)  
56. [Что такое сокрытие методов - method hiding](#что-такое-сокрытие-методов---method-hiding)  
57. [Как реализована неизменность string](#как-реализована-неизменность-string)  
58. [В какой области памяти хранятся примитивы](#в-какой-области-памяти-хранятся-примитивы)  
59. [В какой области памяти хранятся объекты](#в-какой-области-памяти-хранятся-объекты)  
60. [Где хранятся ссылки на объект](#где-хранятся-ссылки-на-объект)  
61. [Как реализовать свой immutable тип данных](#как-реализовать-свой-immutable-тип-данных)  
62. [Что такое позднее и раннее связывание](#что-такое-позднее-и-раннее-связывание)  
63. [Что такое varargs какие-есть-ограничения-при-написании](#что-такое-varargs-какие-есть-ограничения-при-написании)  
64. [Для чего нужна аннотация override](#для-чего-нужна-аннотация-override)  
65. [В чем разница между передачей параметров по ссылке или по значению](#в-чем-разница-между-передачей-параметров-по-ссылке-или-по-значению)  
66. [Какие модификаторы доступа бывают у классов](#какие-модификаторы-доступа-бывают-у-классов)  
67. [Класс object и класс class](#класс-object-и-класс-class)  
68. [Правила хэшкод для одного и того же объекта и тд](#правила-хэшкод-для-одного-и-того-же-объекта-и-тд)  
69. [Может ли быть абстрактный класс без абстрактных методов](#может-ли-быть-абстрактный-класс-без-абстрактных-методов)  
70. [Может ли быть конструктор у абстрактного класса](#может-ли-быть-конструктор-у-абстрактного-класса)  
71. [Что такое статическое и динамическое связывание](#что-такое-статическое-и-динамическое-связывание)  
72. [В чем разница между thisgetclass--thatgetclass-и-that-instanceof-myclass](#в-чем-разница-между-thisgetclass--thatgetclass-и-that-instanceof-myclass)  
73. [Чем отличается параметрический полиморфизм от ad-hoc](#чем-отличается-параметрический-полиморфизм-от-ad-hoc)  
74. [Что такое heap и stack память в java](#что-такое-heap-и-stack-память-в-java)  
75. [Для чего нужен сборщик мусора](#для-чего-нужен-сборщик-мусора)  
76. [Когда в приложении может быть выброшено исключение classcastexception](#когда-в-приложении-может-быть-выброшено-исключение-classcastexception)  
77. [solid](#solid)  
78. [Алгоритм определения equals](#алгоритм-определения-equals)  
79. [Контракт hashcod](#контракт-hashcod)  
80. [Отличие интерфейсов от абстрактных классов](#отличие-интерфейсов-от-абстрактных-классов)  




## Что такое ООП? В чем его плюсы

ООП — это парадигма программирования, в которой программа строится вокруг объектов.
У каждого объекта есть:

состояние (поля, данные),

поведение (методы).

Плюсы ООП:

Модульность — код удобно разбивать на классы и пакеты.

Повторное использование — можно переиспользовать код через наследование и библиотеки.

Гибкость — полиморфизм позволяет работать с разными объектами единообразно.

Защита данных — инкапсуляция скрывает внутренние детали.

Масштабируемость — проще поддерживать и расширять большие проекты.

[⬆ Вернуться к содержанию](#содержание)

## Перечислите основные принципы ООП

Основные принципы ООП — это так называемая большая четвёрка:

Абстракция — выделяем главное, скрываем детали реализации.

Инкапсуляция — скрытие внутреннего состояния объекта и работа с ним только через методы.

Наследование — возможность одному классу брать поля и методы другого.

Полиморфизм — один интерфейс, разные реализации (один метод вызывается по-разному у разных объектов).

## Что такое инкапсуляция? Приведите пример инкапсуляции

Инкапсуляция — это принцип ООП, при котором:
внутренние данные и реализация объекта скрываются от внешнего мира,


доступ к ним осуществляется только через публичные методы.


📌 Идея: "данные под замком, ключи — это методы".

## Что такое полиморфизм Приведите пример полиморфизма

Полиморфизм — это принцип ООП, при котором один и тот же вызов метода может вести себя по-разному в зависимости от объекта, к которому он применяется.
📌 Идея: "один интерфейс — много реализаций".
compile-time polymorphism → перегрузка методов (overloading).


runtime polymorphism → переопределение методов (overriding).

Также 👉 Абстрактный класс = «общее поведение + полиморфизм в рамках одной иерархии».
 👉 Интерфейс = «чистый контракт, максимальная гибкость для полиморфизма».
 
## Что такое наследование? Приведите пример наследования? Зачем оно нужно?

Наследование — это принцип ООП, который позволяет одному классу (дочернему) унаследовать свойства и методы другого класса (родительского).
 В Java это делается через ключевое слово extends.
🔹 Зачем нужно наследование?
Повторное использование кода → не пишем одно и то же в каждом классе.


Иерархия классов → строим отношения «is-a» (собака — это животное).


Полиморфизм → можно хранить разные типы объектов в одной коллекции и вызывать общие методы.

## Что такое класс? Объект?

✅ Что такое класс?
Класс — это шаблон (чертёж) для создания объектов.
 В классе мы описываем:
поля (состояние, данные),


методы (поведение, что объект умеет делать).


Что такое объект
✅ Что такое объект?
Объект — это конкретный экземпляр класса, созданный в памяти.
 У него есть свои значения полей и возможность вызывать методы.


7) Как передаются объекты в метод


## Как передаются объекты в метод?

В Java всё передаётся по значению (pass-by-value).
 Но когда речь идёт об объектах, передаётся значение ссылки на объект.
📌 Это значит:
Метод получает копию ссылки.


Эта копия указывает на тот же объект в памяти.


Поэтому:


если мы изменим поля объекта внутри метода → изменения будут видны снаружи,


если мы переназначим ссылку внутри метода на новый объект → снаружи это не повлияет.


## Что такое метод, возвращаемое значение, аргументы метода

Метод — это именованный блок кода внутри класса, который описывает действие (поведение) объекта или класса.
 Метод можно вызывать многократно, передав ему данные (аргументы) и получая результат (возвращаемое значение).

 Возвращаемое значение метода
Тип данных, который метод отдаёт после выполнения.


Если метод ничего не возвращает, указывается void.
Аргументы метода (параметры)
Входные данные, которые передаются в метод.

## Что такое переопределение метода в Java?

Переопределение метода (method overriding) — это когда класс-наследник предоставляет свою собственную реализацию метода, который уже есть в родительском классе.

📌 Правила переопределения:
Имя метода и список параметров должны совпадать.
Возвращаемый тип должен быть таким же или ковариантным (подтип).
Модификатор доступа не может быть более строгим, чем у родителя.
Используется аннотация @Override (необязательно, но рекомендуется).
Только нестатические методы могут быть переопределены.

## Что такое перегрузка метода в Java?

Перегрузка метода (method overloading) — это наличие в одном классе (или в наследнике) нескольких методов с одинаковым именем, но с разными параметрами.

📌 Правила перегрузки:
Имя метода одинаковое.


Список параметров (тип, количество, порядок) должен отличаться.


Возвращаемый тип не влияет на перегрузку.


Перегрузка работает на этапе компиляции (compile-time polymorphism).


## Что такое нативные методы, их плюсы и минусы

Нативные методы (native methods) — это методы в Java, которые реализованы не на Java, а на другом языке (обычно C или C++).
 Они подключаются через JNI (Java Native Interface).

👉 В обычной прикладной разработке их почти не используют.
Чаще встречаются в системных библиотеках Java (например, в System.arraycopy() или методах HashMap), где важна скорость.

Что такое метод, возвращаемое значение, аргументы метода


## Какие модификаторы доступа могут быть у класса

Модификаторы доступа у класса в Java
Нужно различать: топ-уровневый класс (обычный, в отдельном .java файле) и вложенный (inner/nested) класс.

Для топ-уровневого класса:
public → доступен из любого пакета.


(default) package-private (если не указать модификатор) → доступен только внутри своего пакета.


Других модификаторов (private, protected) у топ-классов быть не может.

Для вложенных классов (inner classes):

Могут быть все варианты:
public → доступен везде.


protected → доступен в своём пакете + наследникам.


private → доступен только внутри своего класса.

package-private - доступен только внутри своего пакета.

## Что такое final? Что может быть final? Как они работают?

✅ Что такое final в Java?
Ключевое слово final используется, чтобы запретить изменение чего-либо: переменной, метода или класса.
 Значение зависит от того, к чему применено.

🔹 1. final переменная
Её значение можно присвоить только один раз.

После инициализации изменить нельзя.

🔹 2. final поля класса
Должны быть инициализированы сразу или в конструкторе.


🔹 3. final метод
Такой метод нельзя переопределить в наследниках.
🔹 4. final класс
Такой класс нельзя наследовать.


Пример: String, Integer, Math в стандартной библиотеке Java.

📌 Итог

final переменная → значение не меняется после создания.


final поле → фиксируется при создании объекта. может быть разной у разных объектов.


final метод → не может быть переопределен.


final класс → нельзя наследовать.

## Как реализована неизменность String

✅ Как реализована неизменность String в Java
Класс String в Java является immutable (неизменяемым).
 Это значит: после создания объекта изменить его содержимое уже нельзя.

🔹 Как это реализовано внутри:
Поле хранения символов объявлено private final:

 private final char[] value;   // (в старых версиях)
// или
private final byte[] value;   // (в новых версиях Java для экономии памяти)
 👉 final означает, что ссылка всегда указывает на один и тот же массив.


Нет методов, изменяющих массив напрямую.
 Любая операция (например, concat, replace, substring) возвращает новый объект String, а не меняет старый.


Пул строк (String Pool).
 Благодаря неизменности возможна оптимизация — ссылки на одинаковые строковые литералы указывают на один объект в пуле.


Безопасность.
 Поскольку строка не меняется, её можно безопасно использовать как ключ в HashMap или передавать между потоками.

👉 Благодаря этому строки:
можно кэшировать,


безопасно использовать в многопоточности,


применять как ключи в коллекциях.

## Как реализовать свой Immutable тип данных

Короткая схема (чек-лист):
Сделайте класс final (чтобы его нельзя было расширить и «сломать» неизменность через наследование).


Все поля — private final.


Инициализация только в конструкторе (или через билдера, который в конце создаёт объект).


Никаких сеттеров. Методы, «изменяющие» состояние, должны возвращать новый объект.


Для изменяемых полей (массивы, коллекции, Date, любые мутируемые типы) — делайте defensive copy:


копируйте входящие аргументы в конструкторе;


при геттерах возвращайте копию/неизменяемое представление.


Продумайте корректные equals, hashCode, toString.


## Что такое ключевое слово static? Что может быть static?


📌 Итог:
static = "элемент класса принадлежит классу, а не объекту".


Может применяться к: полям, методам, блокам инициализации, вложенным классам, а также через static import.


 ## Могут ли нестатические методы перегрузить статические?

✅ Могут ли нестатические методы перегрузить статические?
Да, перегрузка (overloading) возможна между статическими и нестатическими методами, потому что перегрузка в Java определяется только сигнатурой метода (имя + параметры).

 Тип метода (static или нет) на перегрузку не влияет.
❌ Но!
Переопределить (override) статический метод нельзя, потому что статические методы принадлежат классу, а не объекту.
 В наследниках можно только скрыть (method hiding) статический метод, если объявить с такой же сигнатурой.

📌 Итог:
Перегрузка: да, возможна (static ↔ non-static).


Переопределение: нет, статические методы не переопределяются.


 ## Что такое пакет? Как создать пакет?

Что такое пакет (package) в Java?
Пакет — это способ организации классов и интерфейсов в группы.
 Можно думать о пакете как о «папке» в файловой системе, которая помогает:
структурировать проект,


избежать конфликтов имён (два класса с одинаковым именем могут жить в разных пакетах),


управлять доступом (модификатор default = доступ только внутри пакета).
В начале .java файла указываем пакет:

 package mypackage;

Файл нужно положить в соответствующую папку:


mypackage/Person.java


В другом классе подключаем через import:

 import mypackage.Person;

public class Main {
    public static void main(String[] args) {
        Person p = new Person();
    }
}
📌 Итог:
Пакет = «пространство имён + папка».


Создаётся через ключевое слово package и соответствующую структуру папок.

## Что такое конструкторы? Конструктор по-умолчанию?

✅ Что такое конструкторы?
Конструктор — это специальный метод в классе, который вызывается при создании объекта.
 Его задача — инициализировать поля объекта.
📌 Отличия от обычного метода:
имя конструктора совпадает с именем класса,


не имеет возвращаемого типа (даже void нельзя указывать),


вызывается автоматически при создании объекта через new.


✅ Конструктор по умолчанию
Если в классе не объявлен ни один конструктор, компилятор автоматически добавляет пустой конструктор без параметров.
📌 Но! Если вы написали хотя бы один конструктор (например, с параметрами) → конструктор по умолчанию уже не создаётся. Если он нужен, его придётся написать явно.

## Что такое this и super? Когда мы обязаны их использовать?

🔹  this — это ссылка на текущий объект.
 Используется:
Чтобы отличить поле класса от параметра метода или конструктора.


Чтобы вызвать другой конструктор внутри того же класса. (Такой вызов всегда должен быть первой строкой конструктора.)



🔹 super
super — это ссылка на родительский (суперкласс).
 Используется:
Чтобы вызвать конструктор родительского класса. (Обязательно первой строкой конструктора наследника, если у родителя нет конструктора по умолчанию.)


Чтобы обратиться к методам или полям родителя, если они перекрыты в наследнике.



👉 Итого:
this → «мой объект».


super → «мой родитель».

## Класс Object и все методы кроме wait, notify, notifyAll

Object — родитель всех классов в Java. Методы:

toString() — строковое представление объекта.

equals(Object o) — сравнение объектов по содержимому.

hashCode() — числовой код для быстрого сравнения, нужен для HashMap, HashSet.

clone() — создаёт копию объекта (поверхностную).

getClass() — возвращает класс объекта (runtime).

finalize() — вызывается перед удалением объекта сборщиком мусора (deprecated).

## Зачем нужен метод finalize

Использовался для освобождения ресурсов (файлы, сокеты) перед удалением объекта.

Сейчас deprecated: лучше использовать try-with-resources и интерфейс AutoCloseable.

## Из-за чего происходят коллизии

Коллизии происходят, когда два или более объекта (или данных) имеют одинаковый хеш-код. 
Причины возникновения коллизий:
Ограниченность диапазона хеш-кодов:


## Разница между instanceOf() и getClass() 

instanceof — проверяет, является ли объект экземпляром класса или его наследника.

getClass() — возвращает точный класс объекта → без учёта наследования.

## Методы класса Enum

values() — возвращает массив всех констант перечисления.

valueOf(String name) — возвращает константу по имени.

ordinal() — позиция константы (с 0).

name() — имя константы.

compareTo(E o) — сравнивает порядок констант.

## Что такое интерфейс. Когда использовать интерфейс

Интерфейс = контракт (набор абстрактных методов), который класс обязан реализовать.

Используем, когда хотим задать поведение без реализации (например, Comparable, Runnable).

## Можно ли создать поля в интерфейсе

Да, но только public static final (константы).

Обычных переменных состояния быть не может.

## Есть ли в Java множественное наследование? Зачем реализовывать интерфейс интерфейсу?

Множественное наследование классов → ❌ нет.

Множественное наследование интерфейсов → ✔ есть (и именно это заменяет множественное наследование в Java). Это безопасно, потому что интерфейсы не содержат состояния (полей, которые можно менять).

Интерфейс может «реализовать» (точнее, расширять) другой интерфейс, чтобы создать более сложный контракт из простых частей. Это удобно для архитектуры и избавляет от дублирования.

## Можно ли создавать статик-методы в интерфейсах

Да, начиная с Java 8.

Вызываются через имя интерфейса (InterfaceName.method()

## Что такое абстрактный метод

Метод без реализации (тело отсутствует).

Определяется в abstract классе или интерфейсе.

Реализация обязана быть в подклассе/классе-реализаторе.

## Что такое абстрактный класс 

Абстрактный класс — это класс, который не может быть использован для создания экземпляров (то есть, вы не можете создать объект этого класса). Он используется как "шаблон" для других классов. В абстрактном классе могут быть как абстрактные методы (методы без реализации), так и обычные методы с реализацией. Основная цель абстрактных классов — предоставить общую основу для других классов, а также обязать их реализовать определённые методы.
не может быть инстанцирован
может содержать как абстрактные так и обычные методы 
может содержать поля и конструкторы

## Какие модификаторы доступа можно использовать в интерфейсе и абстрактном классе?

Top-level (верхнего уровня) интерфейсы и абстрактные классы → только public или package-private (без модификатора).

Вложенные классы и интерфейсы → могут быть public, protected, private, package-private.

В интерфейсе методы по умолчанию → public abstract (даже если не указать).

Поля в интерфейсе всегда public static final.

## Что можно делать при переопределении метода, а что нельзя
Что можно делать при переопределении метода, а что нельзя
Можно:

менять реализацию,

ослаблять модификатор доступа (только в сторону большей доступности),

возвращать ковариантный тип.
Нельзя:

менять сигнатуру (иначе это перегрузка, а не переопределение),

ужесточать модификатор доступа,

переопределять static или final методы.


## Что будет если передать массив в метод, который изменит его значения, изменятся ли они вне метода Почему А если передать примитив
Значения изменятся вне метода — потому что массив это объект, и передаётся копия ссылки.

Если передать примитив → изменится только локальная копия внутри метода, снаружи останется прежнее.

## Передача параметров в методы. По значениюпо ссылке Как передаются примитивы и объекты

В Java всегда по значению.

Примитивы → копируется значение.

Объекты → копируется значение ссылки. Поэтому можно менять поля объекта, но нельзя переназначить ссылку снаружи

## Что такое контракт метода

Это совокупность требований: что метод принимает (входные параметры), что возвращает (тип результата), какие исключения может бросать и какое поведение гарантирует.

Нарушение контракта делает метод небезопасным или непредсказуемым.

## Что такое сокрытие методов - method hiding

Если в подклассе написать static метод с той же сигнатурой, что и в родителе, то это не переопределение, а сокрытие.

Вызов зависит от типа ссылки, а не от реального объекта.

## Как реализована неизменность String

Класс final → нельзя наследовать.

Поле для хранения символов (char[] или byte[]) → private final.

Нет методов, изменяющих массив напрямую → при "изменении" создаётся новый объект.

## В какой области памяти хранятся примитивы

Локальные переменные-примитивы → в стеке.

Примитивные поля объектов → внутри объекта (в куче).

## В какой области памяти хранятся объекты

Объекты (экземпляры классов, массивы) хранятся в куче (heap).

## Где хранятся ссылки на объект

Ссылки (переменные, указывающие на объект) → в стеке, если это локальная переменная.

Если ссылка — поле объекта → тогда ссылка хранится в куче, как часть объекта.

## Как реализовать свой Immutable тип данных

Сделать класс final.

Все поля private final.

Инициализация только через конструктор.

Без сеттеров.

Для изменяемых полей (например, List, Date) → делать копии при сохранении и при возврате (defensive copy).

Переопределить equals, hashCode, toString.

## Для чего нужна аннотация @Override

Показывает, что метод переопределяет метод родителя или интерфейса.

Компилятор проверяет: если метод не соответствует родительскому → ошибка.

Удобно для защиты от случайных опечаток (иначе будет перегрузка вместо переопределения).

## Разница между передачей по ссылке и по значению

По значению (Java) → в метод передаётся копия значения (для объектов — копия ссылки).

По ссылке (другие языки) → в метод передаётся сама ссылка, и её можно переназначить снаружи.

В Java объекты меняются внутри метода (по ссылке), но переназначить саму ссылку нельзя.

## Модификаторы доступа у классов

Top-level класс: public, package-private (default).

Вложенные классы: public, protected, private, package-private.

## Класс Object и класс Class

Object → базовый класс для всех объектов. Методы: toString, equals, hashCode, getClass, clone, finalize.

Class → метаобъект, описывающий структуру класса в runtime (через reflection). Доступ через MyClass.class или obj.getClass().

## Правила hashCode

Для одного и того же объекта метод hashCode должен возвращать одинаковое значение, пока объект не изменился.

Если equals возвращает true, то hashCode обязан совпадать.

Если equals возвращает false, то hashCode может совпадать (коллизии допускаются).

## Может ли быть абстрактный класс без абстрактных методов?

да

## Может ли быть конструктор у абстрактного класса?

да

## Разница между this.getClass() == that.getClass() и that instanceof MyClass

this.getClass() == that.getClass()
→ строгая проверка: объекты должны быть экземплярами одного и того же класса.
→ наследники не пройдут проверку.
👉 Часто используют в реализации equals(), чтобы не считать равными объекты разных подклассов.

that instanceof MyClass
→ мягкая проверка: true, если объект — экземпляр MyClass или его наследников.
👉 Удобно, если мы хотим принимать и расширенные версии класса.

## Параметрический полиморфизм vs ad-hoc

Параметрический = универсальный код для любых типов (generics).

Ad-hoc = разная реализация под разные типы (overloading/overriding).

## Heap и Stack память в Java
🔹 Stack (стек)

Используется для вызовов методов и хранения локальных переменных.

Быстрый, работает по принципу LIFO (last in — first out).

🔹 Heap (куча)

Это область памяти для объектов и массивов.

Управляется сборщиком мусора (GC).

Когда мы создаём объект через new, он всегда помещается в кучу.

В куче хранятся:

сами объекты,

поля объектов (включая примитивы и ссылки).

## Для чего нужен сборщик мусора (GC)
Сборщик мусора (GC):

автоматически находит объекты, на которые нет больше ссылок,

освобождает их память,

предотвращает утечки памяти,

## Когда выбрасывается ClassCastException

ClassCastException выбрасывается, когда мы пытаемся привести объект к типу, которому он на самом деле не принадлежит.

## SOLID
SOLID — это набор из пяти принципов проектирования в ООП.

S — Single Responsibility Principle (Принцип единственной ответственности)
Класс должен иметь только одну причину для изменения. Один класс → одна ответственность.

O — Open/Closed Principle (Принцип открытости/закрытости)
Классы должны быть открыты для расширения, но закрыты для изменения. То есть мы добавляем новое поведение через наследование или композицию, а не лезем менять готовый код.

L — Liskov Substitution Principle (Принцип подстановки Барбары Лисков)
Объекты подклассов должны быть взаимозаменяемы с объектами базового класса. Если Animal — родитель, то Dog должен вести себя как Animal, не ломая логику.

I — Interface Segregation Principle (Принцип разделения интерфейсов)
Лучше много маленьких интерфейсов, чем один огромный. Класс не должен реализовывать методы, которые ему не нужны.

D — Dependency Inversion Principle (Принцип инверсии зависимостей)
Модули верхнего уровня не должны зависеть от модулей нижнего уровня. Оба типа должны зависеть от абстракций.

## Алгоритм определения equals
🔹 Алгоритм написания корректного equals

Проверить ссылку на самого себя:

Если сравниваем объект с самим собой → сразу true.

Проверить на null:
Проверить совместимость классов:

либо через getClass() (строго — равны только объекты одного класса),

либо через instanceof (гибко — можно допускать наследников).

Привести тип:
Сравнить значимые поля (обычно все final или уникальные):

## Контракт hashCode
Согласованность:

Для одного и того же объекта вызов hashCode() всегда должен возвращать одно и то же значение, пока объект не изменился.

Связь с equals:

Если equals() возвращает true, то hashCode() обязан быть одинаковым.

Если equals() возвращает false, то hashCode() может совпадать (коллизии допустимы).

Производительность:

Хорошая хеш-функция должна равномерно распределять объекты по бакетам, чтобы уменьшить число коллизий.
## Отличие интерфейсов от абстрактных классов
Наследование

Класс может наследовать только один абстрактный класс.

Класс может реализовать много интерфейсов.

Поля

В интерфейсе поля всегда public static final (константы).

В абстрактном классе поля могут быть любого модификатора (private, protected, public и т.д.).

Методы

В интерфейсе (до Java 8) все методы абстрактные; начиная с Java 8 → могут быть default, static, с Java 9 → ещё и private.

В абстрактном классе могут быть и абстрактные, и обычные методы.

Конструкторы

У интерфейсов нет конструкторов.

У абстрактных классов есть (для инициализации общих полей).

Назначение

Интерфейс задаёт контракт (что класс умеет делать).

Абстрактный класс задаёт базовое поведение + состояние для наследников.

## Можно ли создать объект не через ключевое слово new?

Да ✅

Через рефлексию: Class.forName("MyClass").newInstance().

Через десериализацию (ObjectInputStream.readObject()).

Через клонирование (clone()).

В String — через литералы ("abc") без new.


## Можно ли переопределить конструктор в классе-наследнике?

❌ Нет.

Конструкторы не наследуются, их нельзя переопределять.

Но можно создать свои конструкторы в наследнике и вызывать super(...).


## Можно ли в классе, который имплементирует интерфейс, реализовать только часть методов?

Если класс обычный → ❌ должен реализовать все методы.

Если класс абстрактный → ✅ может реализовать часть, оставив остальное наследникам.


## Что такое отношения IS-A и HAS-A?

IS-A → «является»: наследование. Dog IS-A Animal.

HAS-A → «содержит»: композиция/агрегация. Car HAS-A Engine.


## Могут ли у абстрактного класса быть конструкторы?

Да ✅

Используются для инициализации общих полей.

Вызываются в наследнике через super(...).

## Могут ли абстрактные классы реализовывать интерфейсы? Должны ли они реализовывать все методы?

Да ✅ абстрактные классы могут implements.

Не обязаны реализовывать все методы → если не реализуют, то сами остаются абстрактными.

## Может ли абстрактный класс быть final?

❌ Нет.

abstract → нужен для наследования.

final → запрещает наследование.

Противоречие.

## Могут ли у абстрактного класса быть статические методы?

Да ✅

Абстрактный класс может содержать static методы, обращаться к ним можно через ClassName.method().

## Обязательно ли в абстрактном классе должны быть абстрактные методы?

❌ Нет.

Абстрактный класс может не содержать абстрактных методов.

## Когда имеет смысл предпочесть абстрактный класс интерфейсу и наоборот?

Абстрактный класс: когда нужен общий код, состояние (поля), конструкторы.

Интерфейс: когда важен только контракт поведения; для множественного наследования.

## Может ли абстрактный класс содержать метод main?

Да ✅

Абстрактный класс может содержать main, его можно запускать как обычный класс.

Просто сам класс нельзя инстанцировать, но main статический, так что всё ок.

## Интерфейсы в механизме обратного вызова (callback)

Интерфейсы часто используются для обратных вызовов.

Класс принимает интерфейс как параметр и вызывает его метод при наступлении события.
