# Вопросы по функциональным интерфейсам и стримам

## Оглавление

1. [Зачем нужно функциональное программирование, где применяется, отличие от ООП/процедурного стиля](#1-зачем-нужно-функциональное-программирование-где-применяется-отличие-от-ооппроцедурного-стиля)
2. [Что такое функциональный интерфейс? Основные функциональные интерфейсы](#2-что-такое-функциональный-интерфейс-основные-функциональные-интерфейсы)
3. [Зачем нужна аннотация FunctionalInterface Обязательна ли Что будет при 2 абстрактных методах](#3-зачем-нужна-аннотация-functionalinterface-обязательна-ли-что-будет-при-2-абстрактных-методах)
4. [Может ли функциональный интерфейс содержать что-то кроме абстрактного метода](#4-может-ли-функциональный-интерфейс-содержать-что-то-кроме-абстрактного-метода)
5. [Что такое default методы в интерфейсе Зачем введены Можно ли переопределять](#5-что-такое-default-методы-в-интерфейсе-зачем-введены-можно-ли-переопределять)
6. [Default методы в функциональных интерфейсах — зачем нужны для обратной совместимости](#6-default-методы-в-функциональных-интерфейсах--зачем-нужны-для-обратной-совместимости)
7. [Все способы реализации функционального интерфейса](#7-все-способы-реализации-функционального-интерфейса)
8. [Что такое анонимный класс Как создать экземпляр Основное свойство](#8-что-такое-анонимный-класс-как-создать-экземпляр-основное-свойство)
9. [Чего нет у анонимного класса](#9-чего-нет-у-анонимного-класса)
10. [Можно ли создать анонимный класс от String](#10-можно-ли-создать-анонимный-класс-от-string)
11. [Что такое лямбда-выражение Как записать Может ли быть в несколько строк](#11-что-такое-лямбда-выражение-как-записать-может-ли-быть-в-несколько-строк)
12. [Как взаимосвязаны лямбда и функциональный интерфейс](#12-как-взаимосвязаны-лямбда-и-функциональный-интерфейс)
13. [Любой анонимный класс можно заменить на лямбду](#13-любой-анонимный-класс-можно-заменить-на-лямбду)
14. [К каким переменным можно обращаться внутри лямбды](#14-к-каким-переменным-можно-обращаться-внутри-лямбды)
15. [Что такое метод-референс В каком виде передаётся](#15-что-такое-метод-референс-в-каком-виде-передаётся)
16. [Расскажите про Comparator и Comparable Разница Методы каждого](#16-расскажите-про-comparator-и-comparable-разница-методы-каждого)
17. [Comparable vs Comparator — разница](#17-comparable-vs-comparator--разница)
18. [Что такое стримы Для чего нужны Когда лучше использовать](#18-что-такое-стримы-для-чего-нужны-когда-лучше-использовать)
19. [Какие бывают стримы](#19-какие-бывают-стримы)
20. [Способы создания стрима](#20-способы-создания-стрима)
21. [Что такое ленивая инициализация стрима](#21-что-такое-ленивая-инициализация-стрима)
22. [Промежуточные операции что возвращают](#22-промежуточные-операции-что-возвращают)
23. [Терминальные операции что возвращают](#23-терминальные-операции-что-возвращают)
24. [Разница map и flatMap Что возвращает flatMap](#24-разница-map-и-flatmap-что-возвращает-flatmap)
25. [Разница forEach и forEachOrdered Разница peek и forEach](#25-разница-foreach-и-foreachordered-разница-peek-и-foreach)
26. [Можно ли вызвать 2 терминальные операции Может ли стрим использоваться повторно](#26-можно-ли-вызвать-2-терминальные-операции-может-ли-стрим-использоваться-повторно)
27. [Для чего параллельные стримы Как сделать Когда невыгодно](#27-для-чего-параллельные-стримы-как-сделать-когда-невыгодно)
28. [Как синтаксически реализован терминальный метод collect](#28-как-синтаксически-реализован-терминальный-метод-collect)
29. [Что такое-optional-и-зачем-нужно](#29-что-такое-optional-и-зачем-нужно)
30. [Что такое Objects и зачем нужен](#30-что-такое-objects-и-зачем-нужен)

---

## 1. Зачем нужно функциональное программирование, где применяется, отличие от ООП/процедурного стиля

Функциональное программирование описывает вычисления через чистые функции без изменения состояния и побочных эффектов. 
Подходит для обработки данных, параллелизма и декларативных преобразований коллекций, в отличие от ООП/процедурного стиля, 
где фокус на изменяемых объектах и пошаговых командах.

## 2. Что такое функциональный интерфейс? Основные функциональные интерфейсы

Функциональный интерфейс — интерфейс с одним абстрактным методом (SAM), 
к которому можно привязать лямбду или метод‑референс. Примеры: Runnable, Callable, 
Comparator, Supplier, Consumer, Function, Predicate и их примитивные варианты.

## 3. Зачем нужна аннотация @FunctionalInterface? Обязательна ли? Что будет при 2 абстрактных методах

Аннотация @FunctionalInterface помечает интерфейс как функциональный и просит компилятор контролировать 
наличие только одного абстрактного метода. Она не обязательна, но при добавлении второго абстрактного метода компилятор выдаст ошибку.

## 4. Может ли функциональный интерфейс содержать что-то кроме абстрактного метода

Может: default‑методы, static‑методы и константы public static final. Главное ограничение — ровно один абстрактный метод.

## 5. Что такое default методы в интерфейсе? Зачем введены (обратная совместимость)? Можно ли переопределять

Default‑методы — это методы с реализацией в интерфейсе, добавленные для обратной совместимости. 
Они позволяют расширять интерфейсы, не ломая старый код, и их можно переопределять в реализующих классах.

## 6. Default методы в функциональных интерфейсах — зачем нужны для обратной совместимости

Default‑методы в функциональных интерфейсах позволяют добавлять новую функциональность, 
не меняя единственный абстрактный метод. Благодаря этому старые реализации и лямбды продолжают работать без изменений.

## 7. Все способы реализации функционального интерфейса

Функциональный интерфейс можно реализовать:
- обычным классом с implements;
- анонимным классом;
- лямбда‑выражением;
- методом‑референсом (Class::staticMethod, obj::instanceMethod, Class::new).

## 8. Что такое анонимный класс? Как создать экземпляр? Основное свойство

Анонимный класс — безымянный класс, создаваемый прямо в месте использования через new InterfaceOrClass() { ... }. 
Экземпляр создаётся сразу вместе с объявлением этого класса.

## 9. Чего НЕТ у анонимного класса?

У анонимного класса нет собственного имени и явных конструкторов. Можно только вызывать 
конструктор родительского класса/интерфейса в выражении new.

## 10. Можно ли создать анонимный класс от String?

Нельзя, потому что String — final и его нельзя расширять ни обычным, ни анонимным классом.

## 11. Что такое лямбда-выражение? Как записать? Может ли быть в несколько строк

Лямбда‑выражение — краткая форма записи реализации функционального интерфейса 
в виде (args) -> тело. Тело может быть как одной строкой‑выражением, так и блоком 
кода в фигурных скобках с несколькими операторами и return.

## 12. Как взаимосвязаны лямбда и функциональный интерфейс

Каждое лямбда‑выражение соответствует одному абстрактному методу функционального интерфейса.
Тип параметров и возвращаемого значения лямбды выводится из сигнатуры этого метода.

## 13. Любой анонимный класс можно заменить на лямбду

Заменить на лямбду можно только анонимный класс, реализующий функциональный интерфейс 
и не использующий специфические возможности класса (например, собственные поля, 
несколько методов, нестандартное использование this/super). В общем случае 
не любой анонимный класс заменяем лямбдой.

## 14. К каким переменным можно обращаться внутри лямбды?

Внутри лямбды доступны:
- параметры метода, в котором объявлена лямбда;
- поля экземпляра и static‑поля;
- локальные переменные, если они эффективно final (не изменяются после присвоения).

## 15. Что такое метод-референс? В каком виде передаётся?

Метод‑референс — компактная ссылка на уже существующий метод
или конструктор вместо лямбды. Записывается как Class::staticMethod, obj::instanceMethod или Class::new 
и подбирается под сигнатуру абстрактного метода функционального интерфейса.

## 16. Расскажите про Comparator и Comparable. Разница? Методы каждого

Comparable задаёт «натуральный» порядок для класса через метод compareTo(T o)
и реализуется самим классом. Comparator — внешний сравниватель с методом compare(T o1, T o2) 
и вспомогательными методами (reverseOrder, comparing и т.п.) для задания разных вариантов сортировки.

## 17. Comparable vs Comparator — разница

Comparable даёт один встроенный естественный порядок у самого класса. Comparator позволяет 
создавать несколько независимых стратегий сравнения снаружи (по имени, дате, цене и т.д.).

## 18. Что такое стримы? Для чего нужны? Когда лучше использовать

Стримы — это последовательность элементов с поддержкой декларативных 
операций вроде фильтрации, маппинга и агрегации. Их удобно использовать, 
когда нужно построить конвейер преобразований данных без явных циклов 
и ручного управления коллекциями.

## 19. Какие бывают стримы?

Стримы делят на:
- конечные и бесконечные (iterate, generate);
- последовательные и параллельные;
- объектные (Stream<T>) и примитивные (IntStream, LongStream, DoubleStream).

## 20. Способы создания стрима (включая бесконечные: iterate(), generate())

Стримы создают:
- из коллекций: collection.stream(), collection.parallelStream();
- из массивов: Arrays.stream(...);
- фабричными методами: Stream.of(...);
- из IO/файлов и других источников;
- как бесконечные: Stream.iterate(...), Stream.generate(...).

## 21. Что такое ленивая инициализация стрима

Промежуточные операции стрима не выполняются сразу, а накапливаются как описание конвейера. 
Реальное вычисление запускается только при вызове терминальной операции.

## 22. Промежуточные операции: что возвращают? Примеры

Промежуточные операции возвращают новый Stream и позволяют строить цепочки, оставаясь ленивыми. 
Примеры: filter, map, flatMap, distinct, sorted, peek, limit, skip.

## 23. Терминальные операции: что возвращают? Примеры

Терминальные операции завершают конвейер и возвращают результат (значение, коллекцию, Optional) 
или выполняют побочный эффект. Примеры: forEach, collect, reduce, count, anyMatch, allMatch, noneMatch, findFirst, findAny.

## 24. Разница map и flatMap? Что возвращает flatMap

map отображает каждый элемент в один другой объект и сохраняет уровень вложенности.
flatMap берёт элемент, превращает его в поток или коллекцию, а затем разворачивает все полученные потоки в один плоский стрим.

## 25. Разница forEach() и forEachOrdered()? Разница peek() и forEach()

В параллельном стриме forEach не гарантирует порядок обхода, а forEachOrdered сохраняет встречный порядок.
peek — промежуточная операция для «подглядывания» в поток (например, логирования), а forEach — терминальная операция, 
которая запускает выполнение конвейера.

## 26. Можно ли вызвать 2 терминальные операции? Может ли стрим использоваться повторно? Что будет без терминальной

Один и тот же стрим нельзя использовать повторно: после первой терминальной операции он считается потреблённым.
Вызов второй терминальной операции на том же стриме приведёт к ошибке; чтобы выполнить ещё одну операцию, нужно создать новый стрим.
Без терминальной операции конвейер не выполняется.

## 27. Для чего параллельные стримы? Как сделать (parallel())? Когда невыгодно

Параллельные стримы используют несколько потоков для ускорения независимой обработки больших объёмов данных. 
Их создают через parallelStream() или stream().parallel(). Они невыгодны для маленьких коллекций, 
IO‑сценариев и сильно синхронизированного кода из‑за накладных расходов и возможных проблем с порядком.

## 28. Как синтаксически реализован терминальный метод collect()

collect реализован как обобщённый терминальный метод, который принимает специальный объект 
Collector либо тройку функций: supplier, accumulator, combiner. На практике используют 
фабрики из Collectors: toList, toSet, toMap, groupingBy и другие.

## 29. Что такое Optional и зачем нужно

Optional — контейнер, который может содержать значение или быть пустым, 
явно представляя ситуацию «значения может не быть». Он помогает избегать прямой работы с null за счёт методов of, 
ofNullable, orElse, orElseGet, orElseThrow, ifPresent и цепочек преобразований.

## 30. Что такое Objects и зачем нужен
Objects — утилитный класс с набором статических методов для работы с объектами: requireNonNull,
equals, hash, compare, isNull, nonNull и т.п. Он упрощает проверки на null, сравнение объектов и построение хеш‑кодов.

flatmap пример использования в коде 
