# Вопросы по функциональным интерфейсам и стримам

## Оглавление

1. [Зачем нужно функциональное программирование, где применяется, отличие от ООП/процедурного стиля](#1-зачем-нужно-функциональное-программирование-где-применяется-отличие-от-ооппроцедурного-стиля)
2. [Что такое функциональный интерфейс? Основные функциональные интерфейсы](#2-что-такое-функциональный-интерфейс-основные-функциональные-интерфейсы)
3. [Зачем нужна аннотация FunctionalInterface Обязательна ли Что будет при 2 абстрактных методах](#3-зачем-нужна-аннотация-functionalinterface-обязательна-ли-что-будет-при-2-абстрактных-методах)
4. [Может ли функциональный интерфейс содержать что-то кроме абстрактного метода](#4-может-ли-функциональный-интерфейс-содержать-что-то-кроме-абстрактного-метода)
5. [Что такое default методы в интерфейсе Зачем введены Можно ли переопределять](#5-что-такое-default-методы-в-интерфейсе-зачем-введены-можно-ли-переопределять)
6. [Default методы в функциональных интерфейсах — зачем нужны для обратной совместимости](#6-default-методы-в-функциональных-интерфейсах--зачем-нужны-для-обратной-совместимости)
7. [Все способы реализации функционального интерфейса](#7-все-способы-реализации-функционального-интерфейса)
8. [Что такое анонимный класс Как создать экземпляр Основное свойство](#8-что-такое-анонимный-класс-как-создать-экземпляр-основное-свойство)
9. [Чего нет у анонимного класса](#9-чего-нет-у-анонимного-класса)
10. [Можно ли создать анонимный класс от String](#10-можно-ли-создать-анонимный-класс-от-string)
11. [Что такое лямбда-выражение Как записать Может ли быть в несколько строк](#11-что-такое-лямбда-выражение-как-записать-может-ли-быть-в-несколько-строк)
12. [Как взаимосвязаны лямбда и функциональный интерфейс](#12-как-взаимосвязаны-лямбда-и-функциональный-интерфейс)
13. [Любой анонимный класс можно заменить на лямбду](#13-любой-анонимный-класс-можно-заменить-на-лямбду)
14. [К каким переменным можно обращаться внутри лямбды](#14-к-каким-переменным-можно-обращаться-внутри-лямбды)
15. [Что такое метод-референс В каком виде передаётся](#15-что-такое-метод-референс-в-каком-виде-передаётся)
16. [Расскажите про Comparator и Comparable Разница Методы каждого](#16-расскажите-про-comparator-и-comparable-разница-методы-каждого)
17. [Comparable vs Comparator — разница](#17-comparable-vs-comparator--разница)
18. [Что такое стримы Для чего нужны Когда лучше использовать](#18-что-такое-стримы-для-чего-нужны-когда-лучше-использовать)
19. [Какие бывают стримы](#19-какие-бывают-стримы)
20. [Способы создания стрима](#20-способы-создания-стрима)
21. [Что такое ленивая инициализация стрима](#21-что-такое-ленивая-инициализация-стрима)
22. [Промежуточные операции что возвращают](#22-промежуточные-операции-что-возвращают)
23. [Терминальные операции что возвращают](#23-терминальные-операции-что-возвращают)
24. [Разница map и flatMap Что возвращает flatMap](#24-разница-map-и-flatmap-что-возвращает-flatmap)
25. [Разница forEach и forEachOrdered Разница peek и forEach](#25-разница-foreach-и-foreachordered-разница-peek-и-foreach)
26. [Можно ли вызвать 2 терминальные операции Может ли стрим использоваться повторно](#26-можно-ли-вызвать-2-терминальные-операции-может-ли-стрим-использоваться-повторно)
27. [Для чего параллельные стримы Как сделать Когда невыгодно](#27-для-чего-параллельные-стримы-как-сделать-когда-невыгодно)
28. [Как синтаксически реализован терминальный метод collect](#28-как-синтаксически-реализован-терминальный-метод-collect)
29. [Что такое Optional и зачем нужно](#29-что-такое-optional-и-зачем-нужно)
30. [Что такое Objects и зачем нужен](#30-что-такое-objects-и-зачем-нужен)

## 1. Зачем нужно функциональное программирование, где применяется, отличие от ООП/процедурного стиля

Функциональное программирование удобно там, где важнее описать что нужно сделать с данными,
а не прописывать пошаговый алгоритм. Оно подходит для сложных преобразований коллекций и потоков 
данных: фильтрации, маппинга, агрегации.

Суть ФП — в использовании чистых функций, которые не меняют внешнее состояние. 
Это делает код предсказуемым и удобным для параллельной обработки.

По сравнению с ООП, где доминируют изменяемые объекты и циклы, функциональный стиль
упрощает конвейерные операции и позволяет писать более декларативно.


## 2. Что такое функциональный интерфейс? Основные функциональные интерфейсы

Функциональный интерфейс — это интерфейс, у которого есть ровно один абстрактный метод. 
Именно к нему можно привязать лямбда-выражение или метод-референс.
Наличие default и static методов не нарушает его функциональность.

Основные стандартные функциональные интерфейсы:
Runnable, Callable, Comparator, Supplier, Consumer, Function, Predicate
и их примитивные варианты (IntPredicate, DoubleFunction и т.д.).

(Java добавила примитивные функциональные интерфейсы — такие как IntPredicate, IntFunction, 
IntConsumer — чтобы избежать лишнего boxing/unboxing при работе со стримами
и повысить производительность. Они работают напрямую с int, long и double.)

## 3. Зачем нужна аннотация @FunctionalInterface? Обязательна ли? Что будет при 2 абстрактных методах

Аннотация @FunctionalInterface помечает интерфейс как функциональный и просит компилятор
контролировать наличие только одного абстрактного метода. Она не обязательна, но при добавлении
второго абстрактного метода компилятор выдаст ошибку.

## 4. Может ли функциональный интерфейс содержать что-то кроме абстрактного метода

Может: default‑методы, static‑методы и константы public static final. Главное ограничение — ровно
один абстрактный метод.

## 5. Что такое default методы в интерфейсе? Зачем введены (обратная совместимость)? Можно ли переопределять

Default‑методы — это методы с реализацией в интерфейсе, добавленные для обратной совместимости. 
Они позволяют расширять интерфейсы, не ломая старый код, и их можно переопределять в реализующих классах.

## 6. Default методы в функциональных интерфейсах — зачем нужны для обратной совместимости

Default‑методы в функциональных интерфейсах позволяют добавлять новую функциональность, 
не меняя единственный абстрактный метод. Благодаря этому старые реализации и лямбды продолжают
работать без изменений.
Когда в Java добавили default‑методы в интерфейсах, это сделали именно ради обратной совместимости: 
можно добавить новый метод с реализацией в интерфейс, и все старые классы, которые его реализуют, не сломаются.


## 7. Все способы реализации функционального интерфейса

Функциональный интерфейс можно реализовать:
- обычным классом с implements;
- анонимным классом;
- лямбда‑выражением;
- методом‑референсом (Class::staticMethod, obj::instanceMethod, Class::new).

## 8. Что такое анонимный класс? Как создать экземпляр? Основное свойство

Анонимный класс — безымянный класс, создаваемый прямо в месте использования 
через new InterfaceOrClass() { ... }. Экземпляр создаётся сразу вместе с объявлением этого класса.

## 9. Чего НЕТ у анонимного класса?

У анонимного класса нет собственного имени и явных конструкторов. Можно только вызывать
конструктор родительского класса/интерфейса в выражении new.

## 10. Можно ли создать анонимный класс от String?

Нельзя, потому что String — final и его нельзя расширять ни обычным, ни анонимным классом.

## 11. Что такое лямбда-выражение? Как записать? Может ли быть в несколько строк

Лямбда-выражение — это краткая форма реализации единственного абстрактного метода функционального интерфейса.
Записывается как (параметры) -> тело. Лямбда может быть многострочной: 
в этом случае используются { } и явный return, если метод должен что-то возвращать.

Как записывается
Общая форма: (параметры) -> выражение или (параметры) -> { блок кода }.​

Пример одной строки: x -> x * 2 или (a, b) -> a + b.

Пример с блоком:

java
(a, b) -> {
    int sum = a + b;
    System.out.println(sum);
    return sum;
}


## 12. Как взаимосвязаны лямбда и функциональный интерфейс

Каждое лямбда‑выражение соответствует одному абстрактному методу функционального интерфейса.
Тип параметров и возвращаемого значения лямбды выводится из сигнатуры этого метода.

## 13. Любой анонимный класс можно заменить на лямбду

Нет, не любой анонимный класс можно заменить на лямбду.

✔ Когда можно заменить

Только если анонимный класс реализует функциональный интерфейс,
то есть имеет один абстрактный метод — и внутри нет ничего сверх этого метода.

✖ Когда нельзя заменить на лямбду

Нельзя заменить, если анонимный класс:

Имеет собственные поля
(у лямбды нет своего состояния).

Содержит больше одного метода
(лямбда реализует только один абстрактный метод).

Использует this или super как ссылку на анонимный класс
(в лямбде this — это внешний класс, а не новая сущность).

Расширяет абстрактный класс, а не интерфейс
Лямбда работает только с функциональными интерфейсами.

Нужны переопределения equals/hashCode/toString
У анонимного класса они свои; у лямбды — нет.

## 14. К каким переменным можно обращаться внутри лямбды?

Внутри лямбды доступны:
- параметры метода, в котором объявлена лямбда;
- поля экземпляра и static‑поля;
- локальные переменные, если они эффективно final (не изменяются после присвоения).

## 15. Что такое метод-референс? В каком виде передаётся?

Метод-референс — это компактная форма лямбды, которая просто вызывает уже существующий 
метод или конструктор. 
Он передаётся в виде Class::staticMethod, obj::instanceMethod,
Class::instanceMethod, или Class::new для конструктора.

## 16. Расскажите про Comparator и Comparable. Разница? Методы каждого

Comparable задаёт «натуральный» порядок для класса через метод compareTo(T o) и реализуется самим классом. 
Comparator — внешний сравниватель с методом compare(T o1, T o2) и вспомогательными методами
(reverseOrder, comparing и т.п.) для задания разных вариантов сортировки.

## 17. Comparable vs Comparator — разница

Comparable задаёт естественный (встроенный) порядок для самого класса через метод compareTo. 
Это означает, что класс сам определяет один вариант сортировки своих экземпляров.

Comparator — внешний сравниватель. Он позволяет создавать сколько угодно разных стратегий 
сортировки: по имени, по дате, по цене, по длине строки и т. д.

## 18. Что такое стримы? Для чего нужны? Когда лучше использовать

Стримы — это последовательность элементов, над которой можно выполнять 
декларативные операции: фильтрацию, преобразование, сортировку, агрегацию.

## 19. Какие бывают стримы?

Стримы делят на:
- конечные и бесконечные (iterate, generate);
- последовательные и параллельные;
- объектные (Stream<T>) и примитивные (IntStream, LongStream, DoubleStream).

## 20. Способы создания стрима (включая бесконечные: iterate(), generate())

Стримы можно создать из коллекций (stream(), parallelStream()), 
из массивов (Arrays.stream()), через фабричные методы (Stream.of()),
из IO-источников (например, Files.lines(path)), 
а также как бесконечные стримы через Stream.iterate() и Stream.generate().

## 21. Что такое ленивая инициализация стрима

Промежуточные операции стрима ленивые: они не выполняются сразу, а формируют цепочку
действий — “конвейер”. Реальная обработка элементов происходит только при вызове терминальной 
операции, которая запускает весь конвейер.

## 22. Промежуточные операции: что возвращают? Примеры

Промежуточные операции возвращают новый Stream и позволяют строить цепочки преобразований.
Примеры: map, flatMap, filter, distinct, sorted, limit, peek.

## 23. Терминальные операции: что возвращают? Примеры

Терминальные операции завершают стрим, запускают выполнение всего конвейера и возвращают итоговый результат — это может быть значение, коллекция, Optional или побочный эффект.

Примеры терминальных операций:

forEach() — выполняет действие для каждого элемента

collect() — собирает результат в коллекцию

reduce() — агрегирует элементы в одно значение

count() — возвращает количество элементов

findFirst(), findAny() — возвращают Optional

anyMatch(), allMatch() — возвращают boolean


(Optional = “результат может быть пустым, но не null”.

Побочный эффект = действие, а не данные
(печать, лог, запись в файл, изменение чего-то вне стрима).)

## 24. Разница map и flatMap? Что возвращает flatMap

map делает простое преобразование «один элемент входа → один элемент выхода», структуру потока не меняет (получается Stream<R>).​

flatMap делает «один элемент входа → много (или ноль) элементов выхода» и одновременно расплющивает вложенные стримы/коллекции в один плоский Stream<R>

## 25. Разница forEach() и forEachOrdered()? Разница peek() и forEach()

forEach в параллельном стриме не сохраняет порядок,
forEachOrdered — сохраняет encounter order.

peek — промежуточная операция (просмотр промежуточных значений) для отладки и логирования,
не изменяет элементы
не запускает стрим
выполняется только если есть терминальная стадия 

forEach — терминальная, запускает выполнение стрима и выполняет действие для каждого элемента.

## 26. Можно ли вызвать 2 терминальные операции? Может ли стрим использоваться повторно? Что будет без терминальной

Один и тот же стрим нельзя использовать повторно. После первой терминальной операции стрим считается потреблённым, 
и вторая терминальная операция приведёт к ошибке IllegalStateException. Чтобы выполнить новую операцию, 
нужно создать новый стрим. Без терминальной операции конвейер вообще не выполняется.

## 27. Для чего параллельные стримы? Как сделать (parallel())? Когда невыгодно

Параллельные стримы используют несколько потоков для ускорения независимой обработки больших объёмов данных.
Их включают через parallelStream() или вызовом stream().parallel().
Они невыгодны на маленьких коллекциях, 
в IO-сценариях и сильно синхронизированном коде, потому что накладные расходы
на управление потоками и синхронизацию могут съесть всю потенциальную выгоду, 
плюс возможны проблемы с порядком обработки.

## 28. Как синтаксически реализован терминальный метод collect()

collect реализован как обобщённый терминальный метод, который принимает специальный объект Collector либо 
тройку функций: supplier, accumulator, combiner. На практике используют фабрики из Collectors: toList,
toSet, toMap, groupingBy и другие.

## 29. Что такое Optional и зачем нужно

Optional — контейнер, который может содержать значение или быть пустым, явно представляя ситуацию 
«значения может не быть». Он помогает избегать прямой работы с null за счёт методов of, ofNullable,
orElse, orElseGet, orElseThrow, ifPresent и цепочек преобразований.

## 30. Что такое Objects и зачем нужен

Objects — утилитный класс с набором статических методов для работы с объектами: requireNonNull,
equals, hash, compare, isNull, nonNull и т.п. Он упрощает проверки на null, сравнение объектов
и построение хеш‑кодов.
