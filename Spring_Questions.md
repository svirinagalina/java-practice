# Spring Framework - Вопросы и ответы

## Оглавление

1. [Что такое бин?](#что-такое-бин)
2. [Виды бинов](#виды-бинов)
3. [Чем бин отличается от POJO-класса?](#чем-бин-отличается-от-pojo-класса)
4. [Что такое Inversion of Control и как Spring реализует этот принцип?](#что-такое-inversion-of-control-и-как-spring-реализует-этот-принцип)
5. [Для чего существует такое количество ApplicationContext?](#для-чего-существует-такое-количество-applicationcontext)
6. [Как можно связать бины?](#как-можно-связать-бины)
7. [Что такое Dependency Injection?](#что-такое-dependency-injection)
8. [Какие бины будут использоваться для настройки приложения?](#какие-бины-будут-использоваться-для-настройки-приложения)
9. [Как получить данные из файла .property?](#как-получить-данные-из-файла-property)
10. [Как запустить Spring-приложение из-под сервера Tomcat?](#как-запустить-spring-приложение-из-под-сервера-tomcat)
11. [Что такое Artifacts?](#что-такое-artifacts)
12. [В чем отличие артефакта war от war exploded?](#в-чем-отличие-артефакта-war-от-war-exploded)
13. [Какая разница между аннотациями @Component, @Repository и @Service?](#какая-разница-между-аннотациями-component-repository-и-service)
14. [Как выглядит структура MVC-приложения?](#как-выглядит-структура-mvc-приложения)
15. [Чем контроллер отличается от сервлета?](#чем-контроллер-отличается-от-сервлета)
16. [Какая основная зависимость фреймворка Spring?](#какая-основная-зависимость-фреймворка-spring)
17. [Как вернуть страницу в контроллере? Как вернуть данные?](#как-вернуть-страницу-в-контроллере-как-вернуть-данные)
18. [Принципы работы Spring](#принципы-работы-spring)
19. [Связывание бинов и их жизненный цикл](#связывание-бинов-и-их-жизненный-цикл)
20. [Основные паттерны Spring](#основные-паттерны-spring)

---

## Что такое бин?

Бин — это обычный Java‑объект, но который находится под управлением IoC‑контейнера Spring (ApplicationContext): контейнер сам создает его, внедряет зависимости и управляет его жизненным циклом на основе конфигурации (аннотаций или @Bean‑методов)

## Виды бинов

В Spring есть несколько scope’ов бинов. По умолчанию singleton — один экземпляр бина на весь ApplicationContext. prototype — при каждом обращении к бину создается новый экземпляр. В веб‑приложениях есть request‑scope (один бин на HTTP‑запрос), session‑scope (на HTTP‑сессию пользователя), application‑scope (на всё веб‑приложение/ServletContext) и websocket‑scope (на WebSocket‑сессию

Чаще всего в обычных приложениях используются singleton и prototype.


## Чем бин отличается от POJO-класса?
POJO — это обычный Java‑класс без зависимости от фреймворков. Spring‑бин — это POJO, который находится под управлением IoC‑контейнера Spring: контейнер сам создаёт его, внедряет зависимости и управляет жизненным циклом.

## Что такое Inversion of Control и как Spring реализует этот принцип?

Inversion of Control — это принцип, при котором создание объектов и управление их зависимостями «переворачивается»: вместо того чтобы код сам делать new и связывать объекты, это делает IoC‑контейнер. В Spring этот принцип реализован через ApplicationContext: он читает конфигурацию, создаёт бины, внедряет им зависимости и управляет их жизненным циклом

## Для чего существует такое количество ApplicationContext?

Разные реализации ApplicationContext нужны для разных источников конфигурации и типов приложений:
AnnotationConfigApplicationContext читает конфигурацию из Java‑классов с аннотациями (@Configuration, @ComponentScan, стереотипы) и используется в современных Java‑конфигурациях;
ClassPathXmlApplicationContext загружает конфиг из XML в classpath (классический стиль, часто в легаси);
FileSystemXmlApplicationContext читает XML по пути в файловой системе, удобно, когда конфиг лежит вне jar и его нужно менять без пересборки; WebApplicationContext — специальный контекст для веб‑приложений, интегрируется с сервлет‑контейнером и позволяет, например, иметь request/session‑scoped бины.

## Как можно связать бины?

Бины связываются через Dependency Injection. В Spring это обычно делается через аннотации @Autowired/@Inject: зависимости можно внедрять через конструктор (предпочтительный вариант), сеттеры или поля. Кроме того, бины можно явно «связать» в конфигурации: в JavaConfig через методы @Bean, принимающие другие бины как аргументы, или в старом XML‑подходе через <bean> и <property ref="...">.

Setter‑внедрение имеет смысл, когда зависимость не обязательна или может меняться.



## Что такое Dependency Injection?

Dependency Injection — это способ реализации IoC, при котором объект не создаёт свои зависимости сам, а получает их «снаружи» от контейнера. В Spring IoC‑контейнер (ApplicationContext) создаёт бины и внедряет им зависимости через конструкторы, сеттеры или поля, вместо ручного new внутри классов.

## Какие бины будут использоваться для настройки приложения?

Для настройки приложения используются конфигурационные бины. Обычно это классы с @Configuration и методами @Bean, где объявляются инфраструктурные бины: DataSource, EntityManagerFactory, TransactionManager, настройки безопасности, view‑резолверы и так далее. В старом XML‑подходе те же объекты описывались как <bean> внутри XML‑конфигурации.
​


## Как получить данные из файла .property?

Данные из .properties можно получить, во‑первых, через @Value("${key}") прямо в поле или конструкторе бина. Во‑вторых, через бин Environment — вызвать environment.getProperty("key"). Если нужно подключить дополнительный .properties‑файл, его добавляют в конфигурационный класс через @PropertySource("classpath:my.properties"), после чего те же @Value и Environment начинают видеть эти свойства.

## Как запустить Spring-приложение из-под сервера Tomcat?

Чтобы запустить Spring‑приложение под локальным Tomcat в IntelliJ, 
ты сначала собираешь артефакт war или war exploded,
затем в Run/Debug Configurations создаёшь конфигурацию Tomcat (local), 
добавляешь туда этот артефакт в разделе Deployment и запускаешь сервер;
IDE стартует локальный Tomcat, деплоит туда твой war, 
Tomcat разворачивает приложение, поднимает DispatcherServlet 
и Spring WebApplicationContext, после чего приложение доступно по 
http://localhost:порт/контекст, а все HTTP‑запросы идут через Tomcat в контроллеры Spring.

## Что такое Artifacts?

В контексте Maven/IDEA артефакт — это собранный результат проекта: jar, war и т.п., 
который можно запускать или деплоить на сервер. Конфигурация артефакта описывает, какие классы и ресурсы войдут внутрь и как он будет упакован.

## В чем отличие артефакта war от war exploded?

Веб‑приложение обычно упаковывают в war: это один архивный файл
со стандартной web‑структурой, который удобно отдавать на удалённый
Tomcat или класть в webapps. Вариант war exploded — это тот же war,
но уже развернутый в виде папок и файлов; его обычно используют локально
в IDE, потому что IntelliJ может просто копировать изменённые классы/ресурсы
в эту папку без пересборки архива, и Tomcat сразу подхватывает изменения, 
что ускоряет разработку.


## Какая разница между аннотациями @Component, @Repository и @Service?

- `@Component` — базовая аннотация для любого компонента, который должен стать бином и попасть в контекст
- `@Service` — специализированный вариант @Component для сервисного слоя
- `@Repository` — специализированный вариант @Component для слоя доступа к данным (добавляет перевод исключений в DataAccessException)

- Если вместо @Repository повесить @Component, бин всё равно поднимется и будет работать, но потеряется автоматический перевод исключений работы с базой в унифицированные Spring‑исключения и исчезнет явная семантика «это DAO/репозиторий»

@Controller / @RestController вешается на контроллер (отвечает за запросы и возвращение от бд и нужных методов контроллера. в сервисе бизнес логика)

## Как выглядит структура MVC-приложения?

MVC в Spring: Model — данные и бизнес‑логика (entity, DTO, service, repository), 
View — шаблоны (JSP/Thymeleaf/HTML), Controller — принимает HTTP‑запрос, 
вызывает сервис и выбирает, что вернуть. Типичная цепочка при CRUD: 
клиент → DispatcherServlet → Controller → Service → Repository/DAO → БД → 
обратно в Controller → View или JSON‑ответ.


## Чем контроллер отличается от сервлета?


Сервлет — это низкоуровневый компонент сервлет‑контейнера, который напрямую работает
с HttpServletRequest/HttpServletResponse и сам разбирает URL, параметры и формирует ответ. 
Spring‑контроллер — это обычный бин, для которого DispatcherServlet берёт на себя всю
низкоуровневую работу: мапит URL и HTTP‑методы на методы контроллера, 
заполняет аргументы (@PathVariable, @RequestParam, @RequestBody),
выбирает view или сериализует возвращаемый объект в JSON, а сам жизненный цикл сервлета
и деталей HTTP скрыт внутри Tomcat и DispatcherServlet.


## Какая основная зависимость фреймворка Spring?

spring-core — базовые утилиты и ядро IoC: BeanFactory, ресурсы, общие интерфейсы.
​

spring-beans — механизм описания и управления бинами: их свойства, зависимости, создание, внедрение и базовый жизненный цикл.
​

spring-context — надстройка над core/beans: ApplicationContext, DI‑контейнер, события, @ComponentScan, аннотации конфигурации, профили.
​

spring-web — веб‑слой: работа с Servlet API, HTTP‑запросами и ответами, инфраструктура для Spring MVC.
​

Сердце Spring — это модули spring-core, spring-beans, spring-context и spring-web: 
они отвечают за IoC/DI, управление бинами, контекст приложения и веб‑инфраструктуру.
​

В Spring Boot эти зависимости обычно явно не указывают, а подключают spring-boot-starter-web, 
который подтягивает Spring MVC, ядро Spring, а также встроенный Tomcat и настраивает 
DispatcherServlet и базовую веб‑конфигурацию за нас.


## Как вернуть страницу в контроллере? Как вернуть данные?

Вернуть страницу (view):
Чтобы вернуть страницу, контроллер с @Controller принимает Model, кладёт в него данные через
addAttribute и возвращает строку с именем шаблона — Spring по ней находит view и рендерит HTML.

Чтобы вернуть данные, помечаю метод @ResponseBody или весь класс @RestController
— тогда возвращаемый объект автоматически сериализуется в JSON и уходит в HTTP‑ответ.

## Принципы работы Spring

Spring основан на IoC/DI: контейнер управляет созданием бинов, их жизненным циклом и связями. Вокруг этого строится инфраструктура:
- **AOP** — аспектно-ориентированное программирование
AOP даёт возможность навесить сквозную логику (логирование, безопасность, метрики) на методы бинов без изменения их кода.
Работает через прокси вокруг бина: вызываешь метод сервиса, а перед/после него автоматически выполняется код аспекта.

- **Декларативные транзакции** — управление транзакциями через аннотации
Транзакции настраиваются аннотациями (@Transactional), а не ручным begin/commit/rollback в коде.
Spring через AOP оборачивает вызов метода в транзакцию: при успехе — commit, при исключении — rollback.

- **Обработка запросов в MVC** — маршрутизация и обработка HTTP-запросов
- **Автоконфигурация в Spring Boot** — автоматическая настройка компонентов

## Связывание бинов и их жизненный цикл

**Связывание бинов** происходит при создании контекста:
1. Контейнер сканирует конфигурацию
2. Создает бины
3. Внедряет зависимости

**Жизненный цикл** включает:
1. **Создание** экземпляра
2. **Заполнение** зависимостей
3. **Вызов callback-методов** (например, @PostConstruct)
   (Callback‑методы в Spring — это специальные методы, которые сама Spring вызывает в определённые моменты жизни бина, а не ты вручную. Например, после создания и внедрения зависимостей вызывается @PostConstruct, а перед уничтожением бина — @PreDestroy или метод из destroyMethod/DisposableBean, чтобы ты мог что‑то проинициализировать или корректно закрыть ресурсы в нужный момент.)
4. **Использование** бина
5. **Уничтожение** (для singleton — при закрытии контекста)

## Основные паттерны Spring

Spring активно использует паттерны:
Dependency Injection (IoC) – контейнер сам создаёт и «вкладывает» зависимости в бины, вместо new в коде.
Singleton – большинство бинов по умолчанию в singleton‑scope: один экземпляр на весь ApplicationContext.
Factory (BeanFactory / @Bean) – создание объектов через фабричные методы и конфигурационные классы, а не напрямую через конструктор.
Proxy – для AOP, @Transactional, безопасности: Spring создаёт прокси вокруг бина и перехватывает вызовы методов.
Template Method – JdbcTemplate, RestTemplate и др. реализуют общий шаблон работы (открыть/закрыть ресурсы), а твой код вставляется в нужные шаги.
MVC – разделение на Model, View и Controller в веб‑части: контроллеры обрабатывают запросы, модели держат данные, вьюхи отвечают за отображение.
