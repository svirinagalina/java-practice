# Spring Framework - Вопросы и ответы

## Оглавление

1. [Что такое бин?](#что-такое-бин)
2. [Виды бинов](#виды-бинов)
3. [Чем бин отличается от POJO-класса?](#чем-бин-отличается-от-pojo-класса)
4. [Что такое Inversion of Control и как Spring реализует этот принцип?](#что-такое-inversion-of-control-и-как-spring-реализует-этот-принцип)
5. [Для чего существует такое количество ApplicationContext?](#для-чего-существует-такое-количество-applicationcontext)
6. [Как можно связать бины?](#как-можно-связать-бины)
7. [Что такое Dependency Injection?](#что-такое-dependency-injection)
8. [Какие бины будут использоваться для настройки приложения?](#какие-бины-будут-использоваться-для-настройки-приложения)
9. [Как получить данные из файла .property?](#как-получить-данные-из-файла-property)
10. [Как запустить Spring-приложение из-под сервера Tomcat?](#как-запустить-spring-приложение-из-под-сервера-tomcat)
11. [Что такое Artifacts?](#что-такое-artifacts)
12. [В чем отличие артефакта war от war exploded?](#в-чем-отличие-артефакта-war-от-war-exploded)
13. [Какая разница между аннотациями @Component, @Repository и @Service?](#какая-разница-между-аннотациями-component-repository-и-service)
14. [Как выглядит структура MVC-приложения?](#как-выглядит-структура-mvc-приложения)
15. [Чем контроллер отличается от сервлета?](#чем-контроллер-отличается-от-сервлета)
16. [Какая основная зависимость фреймворка Spring?](#какая-основная-зависимость-фреймворка-spring)
17. [Как вернуть страницу в контроллере? Как вернуть данные?](#как-вернуть-страницу-в-контроллере-как-вернуть-данные)
18. [Принципы работы Spring](#принципы-работы-spring)
19. [Связывание бинов и их жизненный цикл](#связывание-бинов-и-их-жизненный-цикл)
20. [Основные паттерны Spring](#основные-паттерны-spring)

---

## Что такое бин?

Бин — это обычный Java‑объект, но который находится под управлением IoC‑контейнера Spring (ApplicationContext): контейнер сам создает его, внедряет зависимости и управляет его жизненным циклом на основе конфигурации (аннотаций или @Bean‑методов)

## Виды бинов

В Spring есть несколько scope’ов бинов. По умолчанию singleton — один экземпляр бина на весь ApplicationContext. prototype — при каждом обращении к бину создается новый экземпляр. В веб‑приложениях есть request‑scope (один бин на HTTP‑запрос), session‑scope (на HTTP‑сессию пользователя), application‑scope (на всё веб‑приложение/ServletContext) и websocket‑scope (на WebSocket‑сессию

Чаще всего в обычных приложениях используются singleton и prototype.


## Чем бин отличается от POJO-класса?
POJO — это обычный Java‑класс без зависимости от фреймворков. Spring‑бин — это POJO, который находится под управлением IoC‑контейнера Spring: контейнер сам создаёт его, внедряет зависимости и управляет жизненным циклом.

## Что такое Inversion of Control и как Spring реализует этот принцип?

Inversion of Control — это принцип, при котором создание объектов и управление их зависимостями «переворачивается»: вместо того чтобы код сам делать new и связывать объекты, это делает IoC‑контейнер. В Spring этот принцип реализован через ApplicationContext: он читает конфигурацию, создаёт бины, внедряет им зависимости и управляет их жизненным циклом

## Для чего существует такое количество ApplicationContext?

Разные реализации ApplicationContext нужны для разных источников конфигурации и типов приложений:
- `AnnotationConfigApplicationContext` — для Java-конфигурации
- `ClassPathXmlApplicationContext` — для XML из classpath
- `FileSystemXmlApplicationContext` — для XML из файловой системы
- `WebApplicationContext` — для веб-приложений

## Как можно связать бины?

Бины связываются через Dependency Injection. В Spring это обычно делается через аннотации @Autowired/@Inject: зависимости можно внедрять через конструктор (предпочтительный вариант), сеттеры или поля. Кроме того, бины можно явно «связать» в конфигурации: в JavaConfig через методы @Bean, принимающие другие бины как аргументы, или в старом XML‑подходе через <bean> и <property ref="...">.


## Что такое Dependency Injection?

Dependency Injection — это способ реализации IoC, при котором объект не создаёт свои зависимости сам, а получает их «снаружи» от контейнера. В Spring IoC‑контейнер (ApplicationContext) создаёт бины и внедряет им зависимости через конструкторы, сеттеры или поля, вместо ручного new внутри классов.

## Какие бины будут использоваться для настройки приложения?

Для настройки приложения используются конфигурационные бины. Обычно это классы с @Configuration и методами @Bean, где объявляются инфраструктурные бины: DataSource, EntityManagerFactory, TransactionManager, настройки безопасности, view‑резолверы и так далее. В старом XML‑подходе те же объекты описывались как <bean> внутри XML‑конфигурации.
​


## Как получить данные из файла .property?

Данные из .properties можно получить, во‑первых, через @Value("${key}") прямо в поле или конструкторе бина. Во‑вторых, через бин Environment — вызвать environment.getProperty("key"). Если нужно подключить дополнительный .properties‑файл, его добавляют в конфигурационный класс через @PropertySource("classpath:my.properties"), после чего те же @Value и Environment начинают видеть эти свойства.

## Как запустить Spring-приложение из-под сервера Tomcat?

Чтобы запустить Spring‑приложение под локальным Tomcat в IntelliJ, 
ты сначала собираешь артефакт war или war exploded,
затем в Run/Debug Configurations создаёшь конфигурацию Tomcat (local), 
добавляешь туда этот артефакт в разделе Deployment и запускаешь сервер;
IDE стартует локальный Tomcat, деплоит туда твой war, 
Tomcat разворачивает приложение, поднимает DispatcherServlet 
и Spring WebApplicationContext, после чего приложение доступно по 
http://localhost:порт/контекст, а все HTTP‑запросы идут через Tomcat в контроллеры Spring.

## Что такое Artifacts?

В контексте Maven/IDEA артефакт — это собранный результат проекта: jar, war и т.п., 
который можно запускать или деплоить на сервер. Конфигурация артефакта описывает, какие классы и ресурсы войдут внутрь и как он будет упакован.

## В чем отличие артефакта war от war exploded?

Веб‑приложение обычно упаковывают в war: это один архивный файл
со стандартной web‑структурой, который удобно отдавать на удалённый
Tomcat или класть в webapps. Вариант war exploded — это тот же war,
но уже развернутый в виде папок и файлов; его обычно используют локально
в IDE, потому что IntelliJ может просто копировать изменённые классы/ресурсы
в эту папку без пересборки архива, и Tomcat сразу подхватывает изменения, 
что ускоряет разработку.


## Какая разница между аннотациями @Component, @Repository и @Service?

- `@Component` — базовая аннотация для любого компонента, который должен стать бином и попасть в контекст
- `@Service` — специализированный вариант @Component для сервисного слоя
- `@Repository` — специализированный вариант @Component для слоя доступа к данным (добавляет перевод исключений в DataAccessException)

- Если вместо @Repository повесить @Component, бин всё равно поднимется и будет работать, но потеряется автоматический перевод исключений работы с базой в унифицированные Spring‑исключения и исчезнет явная семантика «это DAO/репозиторий»

@Controller / @RestController вешается на контроллер (отвечает за запросы и возвращение от бд и нужных методов контроллера. в сервисе бизнес логика)

## Как выглядит структура MVC-приложения?

Spring MVC делит приложение на слои:
- **Model** — сущности, DTO, сервисы, репозитории
- **View** — шаблоны HTML/Thymeleaf/JSP
- **Controller** — обрабатывает HTTP-запросы и выбирает представление

Поток:
1. Пользователь делает запрос
2. Запрос попадает в DispatcherServlet
3. Тот выбирает контроллер
4. Контроллер вызывает сервисы/репозитории
5. Возвращает модель и имя view

## Чем контроллер отличается от сервлета?

- **Servlet** — это низкоуровневый компонент сервлет-контейнера, который напрямую работает с HttpServletRequest/Response
- **Spring-контроллер** — обычный бин, над которым «сидит» DispatcherServlet: он маршрутизирует запросы и вызывает методы контроллера, а сам контроллер уже не является сервлетом

## Какая основная зависимость фреймворка Spring?

Раньше основной модуль был `spring-core` и связанные с ним `spring-context` и пр. 
Сейчас чаще используют стартеры Spring Boot, например `spring-boot-starter-web`. 

Во многих билд-файлах отдельно не указывают каждую зависимость Spring, потому что стартеры подключают нужные модули транзитивно.

## Как вернуть страницу в контроллере? Как вернуть данные?

**В классическом Spring MVC:**
- Метод контроллера возвращает строку — имя view (шаблона)
- Модель передается через Model/ModelMap/ModelAndView

**В REST-контроллере (@RestController):**
- Метод возвращает данные (объект/список)
- Они автоматически сериализуются в JSON
- Отправляются в ответе

## Принципы работы Spring

Spring основан на IoC/DI: контейнер управляет созданием бинов, их жизненным циклом и связями. Вокруг этого строится инфраструктура:
- **AOP** — аспектно-ориентированное программирование
- **Декларативные транзакции** — управление транзакциями через аннотации
- **Обработка запросов в MVC** — маршрутизация и обработка HTTP-запросов
- **Автоконфигурация в Spring Boot** — автоматическая настройка компонентов

## Связывание бинов и их жизненный цикл

**Связывание бинов** происходит при создании контекста:
1. Контейнер сканирует конфигурацию
2. Создает бины
3. Внедряет зависимости

**Жизненный цикл** включает:
1. **Создание** экземпляра
2. **Заполнение** зависимостей
3. **Вызов callback-методов** (например, @PostConstruct)
4. **Использование** бина
5. **Уничтожение** (для singleton — при закрытии контекста)

## Основные паттерны Spring

Spring активно использует паттерны:
- **Inversion of Control/Dependency Injection** — управление созданием объектов
- **Factory Method** — создание бинов
- **Singleton** — scope singleton
- **Proxy** — AOP, транзакции
- **Template Method** — JdbcTemplate и др.
- **Front Controller** — DispatcherServlet маршрутизирует все запросы к контроллерам

---

**Дата создания:** 2025-12-15
