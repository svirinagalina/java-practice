# Spring Framework - Вопросы и ответы

## Оглавление

1. [Что такое бин?](#что-такое-бин)
2. [Виды бинов](#виды-бинов)
3. [Чем бин отличается от POJO-класса?](#чем-бин-отличается-от-pojo-класса)
4. [Что такое Inversion of Control и как Spring реализует этот принцип?](#что-такое-inversion-of-control-и-как-spring-реализует-этот-принцип)
5. [Для чего существует такое количество ApplicationContext?](#для-чего-существует-такое-количество-applicationcontext)
6. [Как можно связать бины?](#как-можно-связать-бины)
7. [Что такое Dependency Injection?](#что-такое-dependency-injection)
8. [Какие бины будут использоваться для настройки приложения?](#какие-бины-будут-использоваться-для-настройки-приложения)
9. [Как получить данные из файла .property?](#как-получить-данные-из-файла-property)
10. [Как запустить Spring-приложение из-под сервера Tomcat?](#как-запустить-spring-приложение-из-под-сервера-tomcat)
11. [Что такое Artifacts?](#что-такое-artifacts)
12. [В чем отличие артефакта war от war exploded?](#в-чем-отличие-артефакта-war-от-war-exploded)
13. [Какая разница между аннотациями @Component, @Repository и @Service?](#какая-разница-между-аннотациями-component-repository-и-service)
14. [Как выглядит структура MVC-приложения?](#как-выглядит-структура-mvc-приложения)
15. [Чем контроллер отличается от сервлета?](#чем-контроллер-отличается-от-сервлета)
16. [Какая основная зависимость фреймворка Spring?](#какая-основная-зависимость-фреймворка-spring)
17. [Как вернуть страницу в контроллере? Как вернуть данные?](#как-вернуть-страницу-в-контроллере-как-вернуть-данные)
18. [Принципы работы Spring](#принципы-работы-spring)
19. [Связывание бинов и их жизненный цикл](#связывание-бинов-и-их-жизненный-цикл)
20. [Основные паттерны Spring](#основные-паттерны-spring)

---

## Что такое бин?

Бин — это обычный Java‑объект, но который находится под управлением IoC‑контейнера Spring (ApplicationContext): контейнер сам создает его, внедряет зависимости и управляет его жизненным циклом на основе конфигурации (аннотаций или @Bean‑методов)

## Виды бинов

В Spring есть несколько scope’ов бинов. По умолчанию singleton — один экземпляр бина на весь ApplicationContext. prototype — при каждом обращении к бину создается новый экземпляр. В веб‑приложениях есть request‑scope (один бин на HTTP‑запрос), session‑scope (на HTTP‑сессию пользователя), application‑scope (на всё веб‑приложение/ServletContext) и websocket‑scope (на WebSocket‑сессию

Чаще всего в обычных приложениях используются singleton и prototype.


## Чем бин отличается от POJO-класса?
POJO — это обычный Java‑класс без зависимости от фреймворков. Spring‑бин — это POJO, который находится под управлением IoC‑контейнера Spring: контейнер сам создаёт его, внедряет зависимости и управляет жизненным циклом.

## Что такое Inversion of Control и как Spring реализует этот принцип?

Inversion of Control — это принцип, при котором создание объектов и управление их зависимостями «переворачивается»: вместо того чтобы код сам делать new и связывать объекты, это делает IoC‑контейнер. В Spring этот принцип реализован через ApplicationContext: он читает конфигурацию, создаёт бины, внедряет им зависимости и управляет их жизненным циклом

## Для чего существует такое количество ApplicationContext?

Разные реализации ApplicationContext нужны для разных источников конфигурации и типов приложений:
- `AnnotationConfigApplicationContext` — для Java-конфигурации
- `ClassPathXmlApplicationContext` — для XML из classpath
- `FileSystemXmlApplicationContext` — для XML из файловой системы
- `WebApplicationContext` — для веб-приложений

## Как можно связать бины?

Бины связываются через Dependency Injection. В Spring это обычно делается через аннотации @Autowired/@Inject: зависимости можно внедрять через конструктор (предпочтительный вариант), сеттеры или поля. Кроме того, бины можно явно «связать» в конфигурации: в JavaConfig через методы @Bean, принимающие другие бины как аргументы, или в старом XML‑подходе через <bean> и <property ref="...">.


## Что такое Dependency Injection?

Dependency Injection — это способ реализации IoC, при котором объект не создаёт свои зависимости сам, а получает их «снаружи» от контейнера. В Spring IoC‑контейнер (ApplicationContext) создаёт бины и внедряет им зависимости через конструкторы, сеттеры или поля, вместо ручного new внутри классов.

## Какие бины будут использоваться для настройки приложения?

Для настройки приложения используются конфигурационные бины. Обычно это классы с @Configuration и методами @Bean, где объявляются инфраструктурные бины: DataSource, EntityManagerFactory, TransactionManager, настройки безопасности, view‑резолверы и так далее. В старом XML‑подходе те же объекты описывались как <bean> внутри XML‑конфигурации.
​


## Как получить данные из файла .property?

Данные из .properties можно получить, во‑первых, через @Value("${key}") прямо в поле или конструкторе бина. Во‑вторых, через бин Environment — вызвать environment.getProperty("key"). Если нужно подключить дополнительный .properties‑файл, его добавляют в конфигурационный класс через @PropertySource("classpath:my.properties"), после чего те же @Value и Environment начинают видеть эти свойства.

## Как запустить Spring-приложение из-под сервера Tomcat?

Чтобы запустить Spring‑приложение под локальным Tomcat в IntelliJ, 
ты сначала собираешь артефакт war или war exploded,
затем в Run/Debug Configurations создаёшь конфигурацию Tomcat (local), 
добавляешь туда этот артефакт в разделе Deployment и запускаешь сервер;
IDE стартует локальный Tomcat, деплоит туда твой war, 
Tomcat разворачивает приложение, поднимает DispatcherServlet 
и Spring WebApplicationContext, после чего приложение доступно по 
http://localhost:порт/контекст, а все HTTP‑запросы идут через Tomcat в контроллеры Spring.

## Что такое Artifacts?

В контексте Maven/IDEA артефакт — это собранный результат проекта: jar, war и т.п., 
который можно запускать или деплоить на сервер. Конфигурация артефакта описывает, какие классы и ресурсы войдут внутрь и как он будет упакован.

## В чем отличие артефакта war от war exploded?

Веб‑приложение обычно упаковывают в war: это один архивный файл
со стандартной web‑структурой, который удобно отдавать на удалённый
Tomcat или класть в webapps. Вариант war exploded — это тот же war,
но уже развернутый в виде папок и файлов; его обычно используют локально
в IDE, потому что IntelliJ может просто копировать изменённые классы/ресурсы
в эту папку без пересборки архива, и Tomcat сразу подхватывает изменения, 
что ускоряет разработку.


## Какая разница между аннотациями @Component, @Repository и @Service?

- `@Component` — базовая аннотация для любого компонента, который должен стать бином и попасть в контекст
- `@Service` — специализированный вариант @Component для сервисного слоя
- `@Repository` — специализированный вариант @Component для слоя доступа к данным (добавляет перевод исключений в DataAccessException)

- Если вместо @Repository повесить @Component, бин всё равно поднимется и будет работать, но потеряется автоматический перевод исключений работы с базой в унифицированные Spring‑исключения и исчезнет явная семантика «это DAO/репозиторий»

@Controller / @RestController вешается на контроллер (отвечает за запросы и возвращение от бд и нужных методов контроллера. в сервисе бизнес логика)

## Как выглядит структура MVC-приложения?

MVC в Spring: Model — данные и бизнес‑логика (entity, DTO, service, repository), 
View — шаблоны (JSP/Thymeleaf/HTML), Controller — принимает HTTP‑запрос, 
вызывает сервис и выбирает, что вернуть. Типичная цепочка при CRUD: 
клиент → DispatcherServlet → Controller → Service → Repository/DAO → БД → 
обратно в Controller → View или JSON‑ответ.


## Чем контроллер отличается от сервлета?


Сервлет — это низкоуровневый компонент сервлет‑контейнера, который напрямую работает
с HttpServletRequest/HttpServletResponse и сам разбирает URL, параметры и формирует ответ. 
Spring‑контроллер — это обычный бин, для которого DispatcherServlet берёт на себя всю
низкоуровневую работу: мапит URL и HTTP‑методы на методы контроллера, 
заполняет аргументы (@PathVariable, @RequestParam, @RequestBody),
выбирает view или сериализует возвращаемый объект в JSON, а сам жизненный цикл сервлета
и деталей HTTP скрыт внутри Tomcat и DispatcherServlet.


## Какая основная зависимость фреймворка Spring?

Основная «сердцевина» фреймворка Spring — это модуль Core/Beans/Context, который даёт IoC‑контейнер и DI (BeanFactory / ApplicationContext). Но в реальных веб‑проектах на Spring Boot чаще говорят не про отдельные модули, а про стартер spring-boot-starter-web: он подтягивает всё нужное для веба — Spring MVC, Spring Web, встроенный Tomcat, DispatcherServlet и базовую конфигурацию. В большинстве билд‑файлов отдельные зависимости вроде spring-core, spring-context, spring-webmvc явно не указывают, потому что стартеры Spring Boot (например, spring-boot-starter-web) уже включают их как транзитивные зависимости, и версиями этих модулей управляет сам Boot через свой BOM/parent, поэтому достаточно указать только один стартер, а всё остальное «подтянется» автоматически.

## Как вернуть страницу в контроллере? Как вернуть данные?

Вернуть страницу (view):
в классе с @Controller метод помечается @GetMapping/@PostMapping, принимает Model и возвращает
String — имя view. В методе ты вызываешь сервис, кладёшь данные в model.addAttribute("key", value), 
а Spring по возвращённой строке находит шаблон (JSP/Thymeleaf) и рендерит HTML.

**В REST-контроллере (@RestController):**
- Метод возвращает данные (объект/список)
- Они автоматически сериализуются в JSON
- Отправляются в ответе

## Принципы работы Spring

Spring основан на IoC/DI: контейнер управляет созданием бинов, их жизненным циклом и связями. Вокруг этого строится инфраструктура:
- **AOP** — аспектно-ориентированное программирование
- **Декларативные транзакции** — управление транзакциями через аннотации
- **Обработка запросов в MVC** — маршрутизация и обработка HTTP-запросов
- **Автоконфигурация в Spring Boot** — автоматическая настройка компонентов

## Связывание бинов и их жизненный цикл

**Связывание бинов** происходит при создании контекста:
1. Контейнер сканирует конфигурацию
2. Создает бины
3. Внедряет зависимости

**Жизненный цикл** включает:
1. **Создание** экземпляра
2. **Заполнение** зависимостей
3. **Вызов callback-методов** (например, @PostConstruct)
   (Callback‑методы в Spring — это специальные методы, которые сама Spring вызывает в определённые моменты жизни бина, а не ты вручную. Например, после создания и внедрения зависимостей вызывается @PostConstruct, а перед уничтожением бина — @PreDestroy или метод из destroyMethod/DisposableBean, чтобы ты мог что‑то проинициализировать или корректно закрыть ресурсы в нужный момент.)
4. **Использование** бина
5. **Уничтожение** (для singleton — при закрытии контекста)

## Основные паттерны Spring

Spring активно использует паттерны:
- **Inversion of Control/Dependency Injection** — управление созданием объектов
- **Factory Method** — создание бинов
- **Singleton** — scope singleton
- **Proxy** — AOP, транзакции
- **Template Method** — JdbcTemplate и др.
- **Front Controller** — DispatcherServlet маршрутизирует все запросы к контроллерам

