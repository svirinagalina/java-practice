# Оглавление

## Generics
- [Что такое generic и для чего они нужны?](#что-такое-generic-и-для-чего-они-нужны)
- [Зачем вообще ввели дженерики? Как до дженериков программировали?](#зачем-вообще-ввели-дженерики-как-до-дженериков-программировали)
- [Преимущества кода с использованием Generic по сравнению с кодом без Generic](#преимущества-кода-с-использованием-generic-по-сравнению-с-кодом-без-generic)
- [Что можно параметризовать?](#что-можно-параметризовать)
- [Как параметризовать статический метод?](#как-параметризовать-статический-метод)
- [Почему в статические методы не передается тип класса?](#почему-в-статические-методы-не-передается-тип-класса)
- [Ограничения дженериков](#ограничения-дженериков)
- [Что такое даймонд оператор?](#что-такое-даймонд-оператор)
- [Что такое raw type? К чему приводит использование raw type?](#что-такое-raw-type-к-чему-приводит-использование-raw-type)
- [Какие проблемы могут быть при использовании raw type?](#какие-проблемы-могут-быть-при-использовании-raw-type)
- [Стирание типов? Что такое стирание?](#стирание-типов-что-такое-стирание)
- [Если поле типизировано дженериком как в байт коде будет представлен этот тип?](#если-поле-типизировано-дженериком-как-в-байт-коде-будет-представлен-этот-тип)
- [Что такое wildcard? Где используется wildcard? Как используется wildcard?](#что-такое-wildcard-где-используется-wildcard-как-используется-wildcard)
- [Что такое принцип PECS?](#что-такое-принцип-pecs)
- [Upper Bounded Wildcards, Lower Bounded Wildcards?](#upper-bounded-wildcards-lower-bounded-wildcards)
- [В чем отличие ArrayList и ArrayList<?> ?](#в-чем-отличие-arraylist-и-arraylist)
- [Почему последняя строчка не скомпилируется? List<ArrayList> al = new ArrayList<ArrayList>(); ArrayList<List> al = new ArrayList<ArrayList>();](#почему-последняя-строчка-не-скомпилируется)
- [Что такое ковариантность и контравариантность?](#что-такое-ковариантность-и-контравариантность)
- [Что такое инвариантность?](#что-такое-инвариантность)
- [Всегда ли Generics инварианты?](#всегда-ли-generics-инварианты)
- [Что такое коллекции в Java?](#что-такое-коллекции-в-java)
- [Преимущества использования коллекций?](#преимущества-использования-коллекций)
- [Отличие коллекции от массива? С чем работают коллекции, а с чем массивы?](#отличие-коллекции-от-массива-с-чем-работают-коллекции-а-с-чем-массивы)
- [Какие структуры данных вы знаете?](#какие-структуры-данных-вы-знаете)
- [Расскажи про иерархию коллекций?](#расскажи-про-иерархию-коллекций)
- [Основные коллекции интерфейса Collection?](#основные-коллекции-интерфейса-collection)
- [Основные коллекции интерфейса Map?](#основные-коллекции-интерфейса-map)
- [Что такое Map? Что должно быть уникальным?](#что-такое-map-что-должно-быть-уникальным)
- [Что будет, если в Map положить два значения с одинаковым ключом?](#что-будет-если-в-map-положить-два-значения-с-одинаковым-ключом)
- [Почему Map не наследуется от Collection?](#почему-map-не-наследуется-от-collection)
- [Что вы знаете о коллекциях типа List?](#что-вы-знаете-о-коллекциях-типа-list)
- [Что вы знаете о коллекциях типа LinkedList?](#что-вы-знаете-о-коллекциях-типа-linkedlist)
- [Расскажи отличия/сходства List от Set?](#расскажи-отличиясходства-list-от-set)
- [Расскажи отличия/сходства ArrayList от LinkedList?](#расскажи-отличиясходства-arraylist-от-linkedlist)
- [Когда лучше использовать ArrayList, а когда LinkedList?](#когда-лучше-использовать-arraylist-а-когда-linkedlist)
- [Отличие двусвязного и односвязного списка?](#отличие-двусвязного-и-односвязного-списка)
- [Что вы знаете о коллекциях типа Set?](#что-вы-знаете-о-коллекциях-типа-set)
- [Что вы знаете о коллекциях типа Queue?](#что-вы-знаете-о-коллекциях-типа-queue)
- [Что вы знаете о коллекциях типа Deque?](#что-вы-знаете-о-коллекциях-типа-deque)
- [Что вы знаете о коллекциях типа Stack?](#что-вы-знаете-о-коллекциях-типа-stack)
- [В чём разница между Queue и Deque и Stack?](#в-чём-разница-между-queue-и-deque-и-stack)
- [Что вы знаете о коллекциях типа HashMap?](#что-вы-знаете-о-коллекциях-типа-hashmap)
- [Как работает HashMap? Расскажите подробно, как работает метод put? Что происходит при коллизии?](#как-работает-hashmap-расскажите-подробно-как-работает-метод-put-что-происходит-при-коллизии)
- [Как работает метод get в HashMap?](#как-работает-метод-get-в-hashmap)
- [Как решается коллизия HashMap?](#как-решается-коллизия-hashmap)
- [Что такое HashtTable, чем она отличается от HashMap?](#что-такое-hashtable-чем-она-отличается-от-hashmap)
- [Может ли null быть ключом в HashMap?](#может-ли-null-быть-ключом-в-hashmap)
- [Что вы знаете о коллекциях типа HashSet?](#что-вы-знаете-о-коллекциях-типа-hashset)
- [Как работает HashSet? Что внутри Node? (?)](#как-работает-hashset-что-внутри-node)
- [Что в HashSet используется вместо значений HashMap?](#что-в-hashset-используется-вместо-значений-hashmap)
- [Почему в HashSet используется new Object а не null для value значений?](#почему-в-hashset-используется-new-object-а-не-null-для-value-значений)
- [Как работает метод contains в ArrayList, LinkedList, HashSet?](#как-работает-метод-contains-в-arraylist-linkedlist-hashset)
- [Дайте определение понятию "итератор"?](#дайте-определение-понятию-итератор)
- [Методы Iterator?](#методы-iterator)
- [В чём разница между Iterator и Iterable?](#в-чём-разница-между-iterator-и-iterable)
- [В каких случаях нужно использовать iterator? И почему?](#в-каких-случаях-нужно-использовать-iterator-и-почему)
- [Зачем в итераторе метод remove?](#зачем-в-итераторе-метод-remove)
- [Условия перестроения в красно-черное дерево (одеревенение) HashMap?/При каких условиях в HashMap LinkedList преобразуется в красно-черное дерево?](#условия-перестроения-в-красно-черное-дерево-одеревенение-hashmap-при-каких-условиях-в-hashmap-linkedlist-преобразуется-в-красно-черное-дерево)
- [В чем разница между интерфейсами Comparable и Comparator?](#в-чем-разница-между-интерфейсами-comparable-и-comparator)
- [Что возвращает Comparator и Comparable?](#что-возвращает-comparator-и-comparable)
- [Какие есть способы перебора всех элементов List?](#какие-есть-способы-перебора-всех-элементов-list)


## Что такое generic и для чего они нужны?
Generics это механизм параметризаии типов в Java. Они позволяют писать обощенный код, который работает с разными типами данных, сохраняя безопасность типов на этапел компиляции. 
Они нужны чтобы:
-- избежать ClassCastException во время выполнения 
-- не писать повторяющийся код для разных типов
-- обеспечаить типовую безопасность и читаемость. 

## Зачем вообще ввели дженерики? Как до дженериков программировали?
До появления дженериков (в Java5) использовались коллекции без типизации - так  называемые raw types. В них можно было хранить объекты любых типов, и разработчик должен был сам приводить типы вручную при извлечении. Это часто приводило к ClassCastException. Дженерики ввели, чтобы обеспечить проверку типов на этапе компиляции, избавиться от явных приведений типов, сделать код безопаснее, универсальнее и чище.

## Преимущества кода с использованием Generic по сравнению с кодом без Generic

Типовая безопасность -- ошибки типов выявляются на этапе компиляции, а не во время выполнения.
Отсутствие явных приведений типов - компилятор знает, какие типы допустимы.
Повторное использование кода - можно писать один универсальный класс/метод для разных типов.
Улучшенная читаемость и поддерживаемость - код понятнее, нет лишних кастов.
Совместимость с типами времени выполнения - дженерики работают с любыми ссылочными типами без дублирования логики.

## Что можно параметризовать?
классы - чтобы работать с разными типами данных, не дублируя код. 
Comparable<T>, List<E>.интерфейсы -- например Comparable<T>, List<E>.
методы -- можно ввести собственный параметр типа только для метода
public static <T> void print(T item) { ... }
конструкторы - аналогично методам, с собственным параметром типа. 
поля и параметры -- можно использовать тип-параметры внутри класса. 
то есть параметризовать можно все, что работает с типами данных, кроме примитивов.

## Как параметризовать статический метод?
перед его возвращаемым типом указывают собственный параметр типа в угловых скобках <T>. Этот параметр не связан с типом класса, даже если сам класс является generic.
такой метод можно вызвать без создания экземпляра класса.
Главное правило: параметр типа статического метода объявляется самим методом, а не наследуется от класса. 

## Почему в статические методы не передается тип класса?
потому что статические методы принадлежат классу, а не объекту. Когда вызывается статический метод, объекта еще нет, значит, и его типовые параметры недоступны. Поэтому статический метод может использовать только собственные параметризованные типы, объявленные в самом методе:
public static <T> void print(T value) { ... }

## Ограничения дженериков
1) Нельзя использовать примитивные типы -- только ссылочные (int -- Integer)
2) Нельзя создавать экземпляры параметризованных типов 
T obj = new T(); // ошибка
3) Нельзя создавать массивы параметризованных типов.


## Что такое даймонд оператор?
Даймонд оператор <> это сокращенная форма записи для дженериков, введенная в Java7. Позволяет компилятору вывести тип автоматически, чтобы не повторять его дважды.
раньше List<String> list = new ArrayList<String>();
после Java7 List<String> list = new ArrayList<>();


## Параметр vs Аргумент (в дженериках)?
Параметр vs Аргумент (в дженериках):

Параметр типа (type parameter) — это переменная типа, объявленная при определении класса, интерфейса или метода.
Пример:

class Box<T> { ... } // T — параметр типа


Аргумент типа (type argument) — это конкретный тип, который подставляется при использовании generic.
Пример:

Box<String> box = new Box<>(); // String — аргумент типа


👉 Параметр — это шаблон (переменная типа),
👉 Аргумент — это фактическое значение (конкретный тип, подставляемый при использовании)


## Что такое raw type? К чему приводит использование raw type?
Это использование обобщенного класса или интерфейса без указания параметра типа. 
Например List list = new ArrayList(); // raw type
Такой код отключает проверку типов на этапе компиляции и возвращает поведение, как до появления дженериков.
Это может привести к ClassCastException во время выполнения, потому что компилятор не знает, какие типы реально хранятся в коллекции. raw types существуют ради совместимости со старым кодом, но использовать их не рекомендуется.


## Какие проблемы могут быть при использовании raw type?
1) Отсутствие проверки типов на этапе компиляции
2) Потеря информации о типах
3) Несовместимость с современными generic-методами
4) Появление предупрежджений (unchecked operations)
   
## Стирание типов? Что такое стирание?
Это механизм, при котором дженерики существуют только на этапе компиляции.
Во время компиляции параметры типа заменяются их границами(или Object), и в байткоде информация о generics отсутствует. Нужно для обратной совместимости со старым кодом. 



## Если поле типизировано дженериком как в байт коде будет представлен этот тип?
В байт-коде тип, указанный через дженерик, не сохраняется -- из-за стирания типов. 
Если поле объявлено как
private T value;

то после компиляции в байт-коде оно будет представлено как
private Object value;

если у T есть ограничение, например
class Box<T extends Number> {private T value};
то в байт-коде это поле будет иметь тип Number
Итого: без ограничений -- Object
c ограничением extnds -- тип этого ограничения 


## Что такое wildcard? Где используется wildcard? Как используется wildcard?
это подстановочный тип, обозначающий неизвестный тип. Используется в дженериках для ограничения того, что можно читать и/или записывать
Например
List<? extends Number> можно читать Number и его подтипы, но нельзя писать (ковариантность)
List <? super Integer> можно писать Integer и его подтипы, но  читать только Object (контрвариативность)
Применяется в параметрах методов для гибкости при работе с обощенными типами


## Что такое принцип PECS?
принцип, который помогает выбирать ограничение wildcard 
Producer extends consumer Super

## Upper Bounded Wildcards, Lower Bounded Wildcards?
Upper bounded wildcard (? extends T) позволяет читать элементы как Т, но не добавлять новые (ковариативность)
Lower Bounded Wildcards (? super T) позволяет добавлять элементы типа Т, но читать только как Object (контрвариативность)

## В чем отличие ArrayList и LinkedList?
ArrayList -- на основе массива, быстрый доступ по индексу, медленные вставки / удаления всередине
LinkedList -- на основе узлов(связаный список), быстрые вставки / удаления, но медленный доступ по индексу 


## Почему последняя строчка не скомпилируется?
List<ArrayList> arrayLists = new ArrayList<ArrayList>();
ArrayList<List> arrayList = new ArrayList<ArrayList>();)

Потому что ArrayList и List разные типы, а дженерики инвариантны, то есть ArrayList здесь не  является подтипом List

## Что такое ковариантность и контравариантность?
ковариантность позволяет использовать подтипы вместо базового типа (? extends T) -- только чтение 
контрвариативность -- позволяет использовать супертипы (? super T) только запись

## Что такое инвариантность?
это когда тип с дженериком нельзя заменить ни подтипом, ни супертипом.

## Всегда ли Generics инварианты?
Да, всегда, но с помощью ? extends и ? можно добиться ковариантности, 

# Коллекции

## Что такое коллекции в Java?
Коллекции в Java — это фреймворк классов и интерфейсов, предназначенный для хранения, обработки и управления группами объектов.
Они заменяют массивы, предоставляя динамический размер, гибкость и удобные методы для добавления, удаления, поиска и сортировки данных.
Основные интерфейсы:


List — упорядоченные коллекции с доступом по индексу;


Set — уникальные элементы без дубликатов;


Map — пары ключ–значение;


Queue/Deque — работа с элементами в порядке добавления (FIFO/LIFO).


Все они входят в Java Collections Framework (JCF).

## Преимущества использования коллекций?
Основные преимущества коллекций в Java:

Динамический размер — не нужно заранее задавать длину, как в массивах.

Универсальность — можно хранить любые объекты.

Типобезопасность — через дженерики (List<String>, Map<Integer, User>).

Удобные операции — добавление, удаление, поиск, сортировка и фильтрация.

Структурированность — множество реализаций под разные задачи (ArrayList, HashSet, HashMap, LinkedList и т.д.).

Интеграция со Stream API — функциональная обработка данных.

Повторное использование и поддержка стандартов — единый API во всех реализациях.

## Отличие коллекции от массива?
Главные отличия коллекций от массивов в Java:

Размер:

Массив — фиксированный размер.

Коллекция — динамически растёт или уменьшается.

Тип данных:

Массив может хранить примитивы и объекты.

Коллекция — только объекты (но можно использовать обёртки, например Integer).

Функциональность:

Массив — простая структура с индексами.

Коллекция — готовые методы для добавления, удаления, поиска, сортировки и итерации.

Гибкость:

Коллекции легко менять (List, Set, Map и т.д.) под задачу.

Массивы требуют ручного управления.

## Какие структуры данных вы знаете?
(твой ответ здесь)

## Расскажи про иерархию коллекций?
(твой ответ здесь)

## Основные коллекции интерфейса Collection?
(твой ответ здесь)

## Основные коллекции интерфейса Map?
(твой ответ здесь)

## Что такое Map? Что должно быть уникальным?
(твой ответ здесь)

## Что будет если в Map положить два значения с одинаковым ключом?
(твой ответ здесь)

## Почему Map не наследуется от Collection?
(твой ответ здесь)

## Порядок следования в коллекциях?
(твой ответ здесь)

## Какую функциональность представляет класс Collections?
(твой ответ здесь)

## Методы интерфейса Collection
(твой ответ здесь)

## Как получить синхронизированную коллекцию из не синхронизированной?
(твой ответ здесь)

## Как получить коллекцию только для чтения?
(твой ответ здесь)

## Какие коллекции синхронизированы?
(твой ответ здесь)

## Что вы знаете о коллекциях типа List?
(твой ответ здесь)

## Что вы знаете о коллекциях типа LinkedList?
(твой ответ здесь)

## Расскажи отличия/сходства List от Set?
(твой ответ здесь)

## Расскажи отличия/сходства ArrayList от LinkedList?
(твой ответ здесь)

## Когда лучше использовать ArrayList а когда LinkedList?
(твой ответ здесь)

## Отличие двусвязного и односвязного списка?
(твой ответ здесь)

## Что вы знаете о коллекциях типа Set?
(твой ответ здесь)

## Что вы знаете о коллекциях типа Queue?
(твой ответ здесь)

## Что вы знаете о коллекциях типа Deque?
(твой ответ здесь)

## Что вы знаете о коллекциях типа Stack?
(твой ответ здесь)

## В чём разница между Queue и Deque и Stack?
(твой ответ здесь)

## Что вы знаете о коллекциях типа HashMap?
(твой ответ здесь)

## Как работает HashMap?
(твой ответ здесь)

## Как работает метод put в HashMap?
(твой ответ здесь)

## Как работает метод get в HashMap?
(твой ответ здесь)

## Чем отличается метод put и get для HashMap?
(твой ответ здесь)

## Как решается коллизия HashMap?
(твой ответ здесь)

## В чем отличие Map от Set?
(твой ответ здесь)

## Что такое Hashtable чем она отличается от HashMap?
(твой ответ здесь)

## Может ли null быть ключом в HashMap?
(твой ответ здесь)

## Какой хэш-код у null в HashMap?
(твой ответ здесь)

## Что вы знаете о коллекциях типа HashSet?
(твой ответ здесь)

## Как работает HashSet?
(твой ответ здесь)

## Что внутри Node в HashSet?
(твой ответ здесь)

## Почему в HashSet используется new Object а не null для value?
(твой ответ здесь)

## Что вы знаете о коллекциях типа LinkedHashMap?
(твой ответ здесь)

## Что вы знаете о коллекциях типа LinkedHashSet?
(твой ответ здесь)

## Что вы знаете о коллекциях типа TreeSet?
(твой ответ здесь)

## Что вы знаете о коллекциях типа TreeMap?
(твой ответ здесь)

## Как работает метод contains в ArrayList LinkedList HashSet?
(твой ответ здесь)

## Дайте определение понятию итератор?
(твой ответ здесь)

## Методы Iterator?
(твой ответ здесь)

## В чём разница между Iterator и Iterable?
(твой ответ здесь)

## В чем разница между Iterator и ListIterator?
(твой ответ здесь)

## В чем разница между Iterator и Enumeration?
(твой ответ здесь)

## В каких случаях нужно использовать iterator и почему?
(твой ответ здесь)

## Почему в классе iterator нет метода для получения следующего элемента без передвижения курсора?
(твой ответ здесь)

## Зачем в итераторе метод remove?
(твой ответ здесь)

## В чём различие между fail-fast и fail-safe итераторами?
(твой ответ здесь)

## Что делать чтобы не возникло ConcurrentModificationException?
(твой ответ здесь)

## Как реализован цикл foreach?
(твой ответ здесь)

## Что такое красно-черное дерево?
(твой ответ здесь)

## Когда HashMap преобразуется в красно-черное дерево





