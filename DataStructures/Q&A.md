# Оглавление

## Generics
- [Что такое generic и для чего они нужны?](#что-такое-generic-и-для-чего-они-нужны)
- [Зачем вообще ввели дженерики? Как до дженериков программировали?](#зачем-вообще-ввели-дженерики-как-до-дженериков-программировали)
- [Преимущества кода с использованием Generic по сравнению с кодом без Generic](#преимущества-кода-с-использованием-generic-по-сравнению-с-кодом-без-generic)
- [Что можно параметризовать?](#что-можно-параметризовать)
- [Как параметризовать статический метод?](#как-параметризовать-статический-метод)
- [Почему в статические методы не передается тип класса?](#почему-в-статические-методы-не-передается-тип-класса)
- [Ограничения дженериков](#ограничения-дженериков)
- [Что такое даймонд оператор?](#что-такое-даймонд-оператор)
- [Что такое raw type? К чему приводит использование raw type?](#что-такое-raw-type-к-чему-приводит-использование-raw-type)
- [Какие проблемы могут быть при использовании raw type?](#какие-проблемы-могут-быть-при-использовании-raw-type)
- [Стирание типов? Что такое стирание?](#стирание-типов-что-такое-стирание)
- [Если поле типизировано дженериком как в байт коде будет представлен этот тип?](#если-поле-типизировано-дженериком-как-в-байт-коде-будет-представлен-этот-тип)
- [Что такое wildcard? Где используется wildcard? Как используется wildcard?](#что-такое-wildcard-где-используется-wildcard-как-используется-wildcard)
- [Что такое принцип PECS?](#что-такое-принцип-pecs)
- [Upper Bounded Wildcards, Lower Bounded Wildcards?](#upper-bounded-wildcards-lower-bounded-wildcards)
- [В чем отличие ArrayList и ArrayList<?> ?](#в-чем-отличие-arraylist-и-arraylist)
- [Почему последняя строчка не скомпилируется? List<ArrayList> al = new ArrayList<ArrayList>(); ArrayList<List> al = new ArrayList<ArrayList>();](#почему-последняя-строчка-не-скомпилируется)
- [Что такое ковариантность и контравариантность?](#что-такое-ковариантность-и-контравариантность)
- [Что такое инвариантность?](#что-такое-инвариантность)
- [Всегда ли Generics инварианты?](#всегда-ли-generics-инварианты)
- [Что такое коллекции в Java?](#что-такое-коллекции-в-java)
- [Преимущества использования коллекций?](#преимущества-использования-коллекций)
- [Отличие коллекции от массива? С чем работают коллекции, а с чем массивы?](#отличие-коллекции-от-массива-с-чем-работают-коллекции-а-с-чем-массивы)
- [Какие структуры данных вы знаете?](#какие-структуры-данных-вы-знаете)
- [Расскажи про иерархию коллекций?](#расскажи-про-иерархию-коллекций)
- [Основные коллекции интерфейса Collection?](#основные-коллекции-интерфейса-collection)
- [Основные коллекции интерфейса Map?](#основные-коллекции-интерфейса-map)
- [Что такое Map? Что должно быть уникальным?](#что-такое-map-что-должно-быть-уникальным)
- [Что будет, если в Map положить два значения с одинаковым ключом?](#что-будет-если-в-map-положить-два-значения-с-одинаковым-ключом)
- [Почему Map не наследуется от Collection?](#почему-map-не-наследуется-от-collection)
- [Что вы знаете о коллекциях типа List?](#что-вы-знаете-о-коллекциях-типа-list)
- [Что вы знаете о коллекциях типа LinkedList?](#что-вы-знаете-о-коллекциях-типа-linkedlist)
- [Расскажи отличия/сходства List от Set?](#расскажи-отличиясходства-list-от-set)
- [Расскажи отличия/сходства ArrayList от LinkedList?](#расскажи-отличиясходства-arraylist-от-linkedlist)
- [Когда лучше использовать ArrayList, а когда LinkedList?](#когда-лучше-использовать-arraylist-а-когда-linkedlist)
- [Отличие двусвязного и односвязного списка?](#отличие-двусвязного-и-односвязного-списка)
- [Что вы знаете о коллекциях типа Set?](#что-вы-знаете-о-коллекциях-типа-set)
- [Что вы знаете о коллекциях типа Queue?](#что-вы-знаете-о-коллекциях-типа-queue)
- [Что вы знаете о коллекциях типа Deque?](#что-вы-знаете-о-коллекциях-типа-deque)
- [Что вы знаете о коллекциях типа Stack?](#что-вы-знаете-о-коллекциях-типа-stack)
- [В чём разница между Queue и Deque и Stack?](#в-чём-разница-между-queue-и-deque-и-stack)
- [Что вы знаете о коллекциях типа HashMap?](#что-вы-знаете-о-коллекциях-типа-hashmap)
- [Как работает HashMap? Расскажите подробно, как работает метод put? Что происходит при коллизии?](#как-работает-hashmap-расскажите-подробно-как-работает-метод-put-что-происходит-при-коллизии)
- [Как работает метод get в HashMap?](#как-работает-метод-get-в-hashmap)
- [Как решается коллизия HashMap?](#как-решается-коллизия-hashmap)
- [Что такое HashtTable, чем она отличается от HashMap?](#что-такое-hashtable-чем-она-отличается-от-hashmap)
- [Может ли null быть ключом в HashMap?](#может-ли-null-быть-ключом-в-hashmap)
- [Что вы знаете о коллекциях типа HashSet?](#что-вы-знаете-о-коллекциях-типа-hashset)
- [Как работает HashSet? Что внутри Node? (?)](#как-работает-hashset-что-внутри-node)
- [Что в HashSet используется вместо значений HashMap?](#что-в-hashset-используется-вместо-значений-hashmap)
- [Почему в HashSet используется new Object а не null для value значений?](#почему-в-hashset-используется-new-object-а-не-null-для-value-значений)
- [Как работает метод contains в ArrayList, LinkedList, HashSet?](#как-работает-метод-contains-в-arraylist-linkedlist-hashset)
- [Дайте определение понятию "итератор"?](#дайте-определение-понятию-итератор)
- [Методы Iterator?](#методы-iterator)
- [В чём разница между Iterator и Iterable?](#в-чём-разница-между-iterator-и-iterable)
- [В каких случаях нужно использовать iterator? И почему?](#в-каких-случаях-нужно-использовать-iterator-и-почему)
- [Зачем в итераторе метод remove?](#зачем-в-итераторе-метод-remove)
- [Условия перестроения в красно-черное дерево (одеревенение) HashMap?/При каких условиях в HashMap LinkedList преобразуется в красно-черное дерево?](#условия-перестроения-в-красно-черное-дерево-одеревенение-hashmap-при-каких-условиях-в-hashmap-linkedlist-преобразуется-в-красно-черное-дерево)
- [В чем разница между интерфейсами Comparable и Comparator?](#в-чем-разница-между-интерфейсами-comparable-и-comparator)
- [Что возвращает Comparator и Comparable?](#что-возвращает-comparator-и-comparable)
- [Какие есть способы перебора всех элементов List?](#какие-есть-способы-перебора-всех-элементов-list)


## Что такое generic и для чего они нужны?
Generics это механизм параметризаии типов в Java. Они позволяют писать обощенный код, который работает с разными типами данных, сохраняя безопасность типов на этапел компиляции. 
Они нужны чтобы:
-- избежать ClassCastException во время выполнения 
-- не писать повторяющийся код для разных типов
-- обеспечаить типовую безопасность и читаемость. 

## Зачем вообще ввели дженерики? Как до дженериков программировали?
До появления дженериков (в Java5) использовались коллекции без типизации - так  называемые raw types. В них можно было хранить объекты любых типов, и разработчик должен был сам приводить типы вручную при извлечении. Это часто приводило к ClassCastException. Дженерики ввели, чтобы обеспечить проверку типов на этапе компиляции, избавиться от явных приведений типов, сделать код безопаснее, универсальнее и чище.

## Преимущества кода с использованием Generic по сравнению с кодом без Generic

Типовая безопасность -- ошибки типов выявляются на этапе компиляции, а не во время выполнения.
Отсутствие явных приведений типов - компилятор знает, какие типы допустимы.
Повторное использование кода - можно писать один универсальный класс/метод для разных типов.
Улучшенная читаемость и поддерживаемость - код понятнее, нет лишних кастов.
Совместимость с типами времени выполнения - дженерики работают с любыми ссылочными типами без дублирования логики.

## Что можно параметризовать?
классы - чтобы работать с разными типами данных, не дублируя код. 
Comparable<T>, List<E>.интерфейсы -- например Comparable<T>, List<E>.
методы -- можно ввести собственный параметр типа только для метода
public static <T> void print(T item) { ... }
конструкторы - аналогично методам, с собственным параметром типа. 
поля и параметры -- можно использовать тип-параметры внутри класса. 
то есть параметризовать можно все, что работает с типами данных, кроме примитивов.

## Как параметризовать статический метод?
перед его возвращаемым типом указывают собственный параметр типа в угловых скобках <T>. Этот параметр не связан с типом класса, даже если сам класс является generic.
такой метод можно вызвать без создания экземпляра класса.
Главное правило: параметр типа статического метода объявляется самим методом, а не наследуется от класса. 

## Почему в статические методы не передается тип класса?
потому что статические методы принадлежат классу, а не объекту. Когда вызывается статический метод, объекта еще нет, значит, и его типовые параметры недоступны. Поэтому статический метод может использовать только собственные параметризованные типы, объявленные в самом методе:
public static <T> void print(T value) { ... }

## Ограничения дженериков
1) Нельзя использовать примитивные типы -- только ссылочные (int -- Integer)
2) Нельзя создавать экземпляры параметризованных типов 
T obj = new T(); // ошибка
3) Нельзя создавать массивы параметризованных типов.


## Что такое даймонд оператор?
Даймонд оператор <> это сокращенная форма записи для дженериков, введенная в Java7. Позволяет компилятору вывести тип автоматически, чтобы не повторять его дважды.
раньше List<String> list = new ArrayList<String>();
после Java7 List<String> list = new ArrayList<>();


## Параметр vs Аргумент (в дженериках)?
Параметр vs Аргумент (в дженериках):

Параметр типа (type parameter) — это переменная типа, объявленная при определении класса, интерфейса или метода.
Пример:

class Box<T> { ... } // T — параметр типа


Аргумент типа (type argument) — это конкретный тип, который подставляется при использовании generic.
Пример:

Box<String> box = new Box<>(); // String — аргумент типа


👉 Параметр — это шаблон (переменная типа),
👉 Аргумент — это фактическое значение (конкретный тип, подставляемый при использовании)


## Что такое raw type? К чему приводит использование raw type?
Это использование обобщенного класса или интерфейса без указания параметра типа. 
Например List list = new ArrayList(); // raw type
Такой код отключает проверку типов на этапе компиляции и возвращает поведение, как до появления дженериков.
Это может привести к ClassCastException во время выполнения, потому что компилятор не знает, какие типы реально хранятся в коллекции. raw types существуют ради совместимости со старым кодом, но использовать их не рекомендуется.


## Какие проблемы могут быть при использовании raw type?
1) Отсутствие проверки типов на этапе компиляции
2) Потеря информации о типах
3) Несовместимость с современными generic-методами
4) Появление предупрежджений (unchecked operations)
   
## Стирание типов? Что такое стирание?
Это механизм, при котором дженерики существуют только на этапе компиляции.
Во время компиляции параметры типа заменяются их границами(или Object), и в байткоде информация о generics отсутствует. Нужно для обратной совместимости со старым кодом. 



## Если поле типизировано дженериком как в байт коде будет представлен этот тип?
В байт-коде тип, указанный через дженерик, не сохраняется -- из-за стирания типов. 
Если поле объявлено как
private T value;

то после компиляции в байт-коде оно будет представлено как
private Object value;

если у T есть ограничение, например
class Box<T extends Number> {private T value};
то в байт-коде это поле будет иметь тип Number
Итого: без ограничений -- Object
c ограничением extnds -- тип этого ограничения 


## Что такое wildcard? Где используется wildcard? Как используется wildcard?
это подстановочный тип, обозначающий неизвестный тип. Используется в дженериках для ограничения того, что можно читать и/или записывать
Например
List<? extends Number> можно читать Number и его подтипы, но нельзя писать (ковариантность)
List <? super Integer> можно писать Integer и его подтипы, но  читать только Object (контрвариативность)
Применяется в параметрах методов для гибкости при работе с обощенными типами


## Что такое принцип PECS?
принцип, который помогает выбирать ограничение wildcard 
Producer extends consumer Super

## Upper Bounded Wildcards, Lower Bounded Wildcards?
Upper bounded wildcard (? extends T) позволяет читать элементы как Т, но не добавлять новые (ковариативность)
Lower Bounded Wildcards (? super T) позволяет добавлять элементы типа Т, но читать только как Object (контрвариативность)

## В чем отличие ArrayList и LinkedList?
ArrayList -- на основе массива, быстрый доступ по индексу, медленные вставки / удаления всередине
LinkedList -- на основе узлов(связаный список), быстрые вставки / удаления, но медленный доступ по индексу 


## Почему последняя строчка не скомпилируется?
List<ArrayList> arrayLists = new ArrayList<ArrayList>();
ArrayList<List> arrayList = new ArrayList<ArrayList>();)

Потому что ArrayList и List разные типы, а дженерики инвариантны, то есть ArrayList здесь не  является подтипом List

## Что такое ковариантность и контравариантность?
ковариантность позволяет использовать подтипы вместо базового типа (? extends T) -- только чтение 
контрвариативность -- позволяет использовать супертипы (? super T) только запись

## Что такое инвариантность?
это когда тип с дженериком нельзя заменить ни подтипом, ни супертипом.

## Всегда ли Generics инварианты?
Да, всегда, но с помощью ? extends и ? можно добиться ковариантности, 

# Коллекции

## Что такое коллекции в Java?
Коллекции в Java — это фреймворк классов и интерфейсов, предназначенный для хранения, обработки и управления группами объектов.
Они заменяют массивы, предоставляя динамический размер, гибкость и удобные методы для добавления, удаления, поиска и сортировки данных.
Основные интерфейсы:


List — упорядоченные коллекции с доступом по индексу;


Set — уникальные элементы без дубликатов;


Map — пары ключ–значение;


Queue/Deque — работа с элементами в порядке добавления (FIFO/LIFO).


Все они входят в Java Collections Framework (JCF).

## Преимущества использования коллекций?
Основные преимущества коллекций в Java:

Динамический размер — не нужно заранее задавать длину, как в массивах.

Универсальность — можно хранить любые объекты.

Типобезопасность — через дженерики (List<String>, Map<Integer, User>).

Удобные операции — добавление, удаление, поиск, сортировка и фильтрация.

Структурированность — множество реализаций под разные задачи (ArrayList, HashSet, HashMap, LinkedList и т.д.).

Интеграция со Stream API — функциональная обработка данных.

Повторное использование и поддержка стандартов — единый API во всех реализациях.

## Отличие коллекции от массива?
Главные отличия коллекций от массивов в Java:

Размер:

Массив — фиксированный размер.

Коллекция — динамически растёт или уменьшается.

Тип данных:

Массив может хранить примитивы и объекты.

Коллекция — только объекты (но можно использовать обёртки, например Integer).

Функциональность:

Массив — простая структура с индексами.

Коллекция — готовые методы для добавления, удаления, поиска, сортировки и итерации.

Гибкость:

Коллекции легко менять (List, Set, Map и т.д.) под задачу.

Массивы требуют ручного управления.

## Какие структуры данных вы знаете?
Массивы (Arrays) — фиксированного размера, удобны для хранения элементов одного типа.
Связанные списки (Linked Lists) — последовательность элементов, где каждый элемент содержит ссылку на следующий.
Стэки (Stacks) — структура с принципом LIFO (последний вошёл — первый вышел).
Очереди (Queues) — структура с принципом FIFO (первый вошёл — первый вышел).
Хэш-таблицы (Hash Tables) — обеспечивают быстрый доступ к данным по ключу.
Деревья (Trees), включая бинарные деревья поиска — иерархическая структура для эффективного поиска и сортировки.
Графы (Graphs) — набор узлов и рёбер, используемые для моделирования сетей.
Множества (Sets) — коллекции уникальных элементов.

## Расскажи про иерархию коллекций?
Иерархия коллекций в Java строится вокруг интерфейса Collection, который расширяет интерфейс Iterable. От Collection идут три основных подинтерфейса: List (упорядоченный набор элементов, допускающий дубликаты), Set (набор уникальных элементов) и Queue (очередь с определённым порядком обработки). Map — отдельный интерфейс для хранения пар ключ-значение, не наследуется от Collection, но тесно связан с коллекциями. Эта структура помогает выбирать подходящую коллекцию в зависимости от задачи — будь то упорядочивание, уникальность или приоритет элементов

## Основные коллекции интерфейса Collection?
Основные коллекции интерфейса Collection — это List, Set и Queue. List — упорядоченный список, допускающий дубликаты, Set — коллекция уникальных элементов без порядка, Queue — очередь, где элементы обрабатываются по определённому порядку (обычно FIFO). 

## Основные коллекции интерфейса Map?
Основные коллекции интерфейса Map — это реализации, которые хранят пары ключ-значение. Самые распространённые из них — HashMap, которая не гарантирует порядок элементов, LinkedHashMap, которая сохраняет порядок вставки, и TreeMap, которая хранит элементы в отсортированном порядке по ключу. Map отличается от Collection тем, что не хранит просто элементы, а именно пары, что позволяет быстро находить значение по ключу.

## Что такое Map? Что должно быть уникальным?
Map — это структура данных, которая хранит пары ключ-значение. Важно понимать, что в Map уникальным должен быть ключ — то есть каждый ключ может встречаться только один раз. Значения при этом могут повторяться или быть любыми. Это позволяет быстро находить нужную информацию по ключу, а не перебирать весь набор данных.

## Что будет если в Map положить два значения с одинаковым ключом?
Если в Map положить два значения с одинаковым ключом, то второе значение перезапишет первое. Ключ в Map должен быть уникальным, поэтому при добавлении пары с уже существующим ключом старое значение просто заменяется новым. Это важно понимать, чтобы не потерять данные случайно. Если тебе нужно хранить несколько значений под одним ключом, стоит рассмотреть другие структуры, например, Map с коллекцией в качестве значения.

## Почему Map не наследуется от Collection?
Map не наследуется от Collection, потому что концептуально они решают разные задачи. Collection — это набор элементов, где важна последовательность, уникальность или порядок, а Map — это структура для хранения пар ключ-значение, где ключи уникальны, а значения могут повторяться. Map не является просто коллекцией элементов, а скорее отображением, где каждый ключ связан с конкретным значением. Именно поэтому Map имеет свой собственный интерфейс, который не расширяет Collection, чтобы чётко разделять эти разные модели данных. 

## Порядок следования в коллекциях?
Порядок следования в коллекциях зависит от конкретной реализации и типа коллекции. Например, в List порядок элементов сохраняется в том виде, в каком вы их добавляете — это упорядоченная коллекция. В Set, например, HashSet, порядок не гарантируется, а LinkedHashSet сохраняет порядок вставки. В Queue порядок обычно определяется принципом FIFO — первый вошёл, первый вышел. В Map, как мы обсуждали, порядок зависит от реализации: HashMap не гарантирует порядок, LinkedHashMap сохраняет порядок вставки, а TreeMap сортирует по ключу (по их естественному порядку или компаратору).

## Какую функциональность представляет класс Collections?
Класс Collections в Java — это утилитарный класс, который предоставляет набор статических методов для работы с коллекциями. Он не хранит данные, а помогает выполнять операции, такие как сортировка, поиск, реверс, заполнение, создание неизменяемых коллекций и многое другое. Это своего рода набор инструментов, который облегчает манипуляции с коллекциями без необходимости писать свой код для таких задач. 

## Методы интерфейса Collection
Интерфейс Collection в Java задаёт базовые методы для работы с группой элементов. Вот ключевые из них:

add(E e) — добавляет элемент в коллекцию.
remove(Object o) — удаляет указанный элемент, если он есть.
contains(Object o) — проверяет, есть ли элемент в коллекции.
size() — возвращает количество элементов.
isEmpty() — проверяет, пуста ли коллекция.
iterator() — возвращает итератор для обхода элементов.
clear() — удаляет все элементы из коллекции.
toArray() — преобразует коллекцию в массив.
Эти методы задают основу для всех коллекций, будь то List, Set или Queue. Понимание их помогает эффективно работать с разными типами коллекций и использовать их возможности по максимуму

## Как получить синхронизированную коллекцию из не синхронизированной?
Чтобы получить синхронизированную версию коллекции из несинхронизированной, в Java используется класс Collections с его статическими методами. Например, если у тебя есть обычный List, ты можешь обернуть его так: Collections.synchronizedList(yourList). Аналогично для Set — Collections.synchronizedSet(yourSet), для Map — Collections.synchronizedMap(yourMap). Это создаст потокобезопасную обёртку вокруг исходной коллекции, позволяя безопасно использовать её в многопоточной среде.

## Как получить коллекцию только для чтения?
Чтобы получить коллекцию только для чтения в Java, можно использовать методы из класса Collections, например, Collections.unmodifiableList(), Collections.unmodifiableSet(), Collections.unmodifiableMap() и так далее. Эти методы возвращают обёртку над исходной коллекцией, которая не позволяет изменять её содержимое — любые попытки добавить, удалить или изменить элементы вызовут исключение UnsupportedOperationException. Это удобный способ защитить данные от случайных изменений, сохраняя при этом возможность безопасного доступа к ним.

## Какие коллекции синхронизированы?
В Java из стандартных коллекций синхронизированными по умолчанию являются только некоторые из старых классов, например, Vector и Hashtable. Они изначально были созданы с учётом потокобезопасности, поэтому методы в них синхронизированы. Современные коллекции из пакета java.util.concurrent, такие как ConcurrentHashMap, CopyOnWriteArrayList и другие, тоже обеспечивают потокобезопасность, но делают это более эффективно, чем просто синхронизация всего метода.

Остальные коллекции, например ArrayList, HashMap, HashSet, по умолчанию не синхронизированы. Чтобы сделать их потокобезопасными, используют методы из класса Collections, например, synchronizedList, synchronizedMap и так далее, которые создают синхронизированную обёртку.

Важно помнить, что синхронизированные коллекции защищают от одновременного доступа, но при итерации по ним всё равно нужно дополнительно синхронизировать блок, чтобы избежать ConcurrentModificationException.

Если ты хочешь работать с потокобезопасными коллекциями, лучше выбирать специализированные из java.util.concurrent, так как они обеспечивают более высокую производительность и гибкость, чем классические синхронизированные коллекции.


## Что вы знаете о коллекциях типа List?
Коллекции типа List в Java — это упорядоченные коллекции, которые позволяют хранить элементы в определённом порядке и получать к ним доступ по индексу. В отличие от множества (Set), List допускает дублирование элементов, то есть один и тот же объект может встречаться несколько раз.

Основные характеристики List:

Порядок элементов сохраняется, то есть элементы располагаются в том порядке, в котором их добавили.
Можно обращаться к элементам по индексу, что даёт быстрый доступ и возможность вставлять или удалять элементы в конкретных позициях.
Позволяет хранить null-значения (в зависимости от реализации).
Самые распространённые реализации List:

ArrayList — основан на массиве, обеспечивает быстрый доступ по индексу, но операции вставки и удаления в середине списка могут быть медленнее.
LinkedList — основан на двусвязном списке, операции вставки и удаления быстрее, но доступ по индексу медленнее.
Vector — устаревшая реализация, похожая на ArrayList, но синхронизированная.
List часто используется, когда важен порядок элементов и возможность работы с позициями, например, для списков задач, очередей с возможностью произвольного доступа, или для хранения последовательностей, где дубликаты допустимы.


## Что вы знаете о коллекциях типа LinkedList?
LinkedList — это одна из реализаций интерфейса List в Java, основанная на двусвязном списке. В отличие от ArrayList, который хранит элементы в массиве, LinkedList хранит каждый элемент в отдельном узле, где есть ссылка на предыдущий и следующий элемент. Это даёт несколько важных особенностей:

Быстрая вставка и удаление элементов в середине списка, потому что не нужно сдвигать остальные элементы, достаточно перенастроить ссылки.
Доступ по индексу медленнее, чем у ArrayList, так как для получения элемента приходится проходить по ссылкам от начала или конца списка.
LinkedList реализует не только List, но и Deque, что позволяет использовать его как двунаправленную очередь — добавлять и удалять элементы с начала и конца эффективно.
Подходит для сценариев, где часто нужно добавлять или удалять элементы в середине или на концах коллекции, но не требуется быстрый случайный доступ.
Если ты работаешь с задачами, где важна производительность при частых изменениях структуры списка, LinkedList может быть хорошим выбором. Но если тебе важен быстрый доступ по индексу, лучше использовать ArrayList.

## Расскажи отличия/сходства List от Set?
List и Set — это два разных интерфейса коллекций в Java, и у каждого есть свои особенности, которые влияют на то, как и когда их лучше использовать.

Сходства:

Оба наследуются от интерфейса Collection, то есть представляют собой набор элементов.
Оба позволяют хранить объекты и предоставляют методы для добавления, удаления и проверки элементов.
Отличия:

Порядок элементов:

List сохраняет порядок добавления элементов. Ты всегда можешь получить элемент по индексу, и порядок будет предсказуемым.
Set не гарантирует порядок элементов (за исключением некоторых реализаций, например, LinkedHashSet, который сохраняет порядок вставки, или TreeSet, который сортирует элементы).
Уникальность элементов:

List допускает дубликаты, то есть один и тот же объект может встречаться несколько раз.
Set гарантирует, что каждый элемент уникален — дубликаты не допускаются.
Доступ к элементам:

List позволяет обращаться к элементам по индексу, что удобно, когда важен порядок и позиция.
Set не предоставляет доступа по индексу, потому что порядок не фиксирован.
Использование:

List подходит, когда важен порядок и возможны повторения — например, список задач, где одна и та же задача может повторяться.
Set лучше использовать, когда нужно хранить уникальные элементы без дубликатов — например, множество уникальных пользователей.

## Расскажи отличия/сходства ArrayList от LinkedList?
ArrayList основан на динамическом массиве — быстрый доступ по индексу, но медленные вставки/удаления в середине.
LinkedList — двусвязный список, быстрые вставки/удаления, но медленный доступ по индексу и больше памяти.

## Когда лучше использовать ArrayList а когда LinkedList?
ArrayList — когда нужно часто читать элементы по индексу и редко вставлять/удалять в середине.
LinkedList — когда часто вставляешь или удаляешь элементы в начале или середине списка.

## Отличие двусвязного и односвязного списка?
Односвязный список — каждый элемент хранит ссылку только на следующий. Можно двигаться только вперёд.
Двусвязный список — каждый элемент хранит ссылки на следующий и предыдущий, можно идти в обе стороны, но он требует больше памяти.

## Что вы знаете о коллекциях типа Set?
Коллекции типа Set хранят только уникальные элементы, то есть без повторов.
Порядок элементов не гарантируется (зависит от реализации).
Используются, когда нужно быстро проверять наличие элемента (contains) или исключить дубликаты.
Основные реализации:


HashSet — не сохраняет порядок, основан на HashMap, быстрый доступ O(1)


LinkedHashSet — сохраняет порядок вставки


TreeSet — хранит элементы отсортированными, основан на TreeMap, O(log n)


## Что вы знаете о коллекциях типа Queue?
Коллекции типа Queue реализуют принцип FIFO (first in — first out) — первым извлекается элемент, который был добавлен раньше.
Используются для организации очередей задач, буферов, потоков данных.

Основные реализации:

LinkedList — базовая реализация очереди

PriorityQueue — элементы упорядочиваются по приоритету

ArrayDeque — двусторонняя очередь (можно добавлять и удалять с обеих сторон, быстрее LinkedList)

## Что вы знаете о коллекциях типа Deque?
Deque (Double Ended Queue) — это очередь, в которую можно добавлять и удалять элементы с обоих концов.
Поддерживает и FIFO, и LIFO (как стек).
Основные реализации:


ArrayDeque — самая быстрая и популярная, без ограничений по размеру.


LinkedList — тоже реализует Deque, но медленнее и потребляет больше памяти.


## Что вы знаете о коллекциях типа Stack?
Stack — структура данных типа LIFO (last in — first out): последним добавлен — первым извлекается.
Используется для вызовов методов, откатов, парсинга выражений и т.п.
Основные реализации:


Класс Stack (устаревший, синхронизированный, из Vector)


Рекомендуемая альтернатива — Deque (ArrayDeque), который быстрее и современнее.


## В чём разница между Queue и Deque и Stack?
Queue — очередь, работает по принципу FIFO (первым вошёл — первым вышел).

Deque — двусторонняя очередь: можно добавлять и удалять с обоих концов, поддерживает и FIFO, и LIFO.

Stack — стек, работает по принципу LIFO (последним вошёл — первым вышел), по сути — частный случай Deque.

## Что вы знаете о коллекциях типа HashMap?
HashMap — коллекция для хранения пар ключ–значение.
Ключи уникальны, значения могут повторяться.
Основана на хэш-таблице, обеспечивает быстрые операции put(), get(), remove() — в среднем O(1).
Особенности:


Порядок элементов не гарантируется.


Допускает null ключ и значения.


Не потокобезопасна.


Основные аналоги:


LinkedHashMap — сохраняет порядок вставки.


TreeMap — хранит ключи отсортированными.




## Как работает HashMap?
HashMap хранит элементы как пары (ключ, значение) внутри массивa бакетов.

Алгоритм работы:

При добавлении вызывается hashCode() ключа.

Хэш код преобразуется в индекс бакета.

Если бакет пуст — пара сохраняется туда.

Если в бакете уже есть элемент с тем же хэшем — выполняется сравнение через equals() (чтобы различать разные ключи с одинаковым хэшем).

При коллизии элементы хранятся в виде связного списка, а при большом числе элементов — в виде красно-чёрного дерева (с Java 8).

Доступ (get) работает так же: вычисляется хэш, ищется нужный бакет, затем ключ через equals().
В среднем операции put() и get() имеют сложность O(1).

## Как работает метод put в HashMap?
Метод put(K key, V value) в HashMap работает так:

Вычисляется hashCode() ключа → по нему определяется индекс бакета (ячейки массива).

Если бакет пуст — создаётся новая пара (key, value).

Если бакет не пуст — проходит по цепочке элементов:

Если найден тот же ключ (по equals()), значение заменяется.

Если ключ другой, но хэш совпал — возникает коллизия, элемент добавляется в цепочку (или в дерево, если их много).

Если количество элементов превышает порог загрузки (load factor, обычно 0.75) — выполняется расширение (resize), и все элементы перераспределяются по новым бакетам.

## Как работает метод get в HashMap?
Метод get(Object key) работает так:


Вычисляется hashCode() ключа.


По хэшу находится индекс бакета в массиве.


В этом бакете ищется элемент:


Если ключ совпадает по equals() — возвращается значение.


Если несколько элементов (коллизия) — перебираются или обходится дерево (если структура преобразована в дерево).




Если ключ не найден — возвращается null.


⏱ В среднем время доступа — O(1), в худшем случае (много коллизий) — O(n).

## Чем отличается метод put и get для HashMap?
put() — добавляет или обновляет пару (ключ, значение):


вычисляет хэш ключа,


ищет бакет,


при совпадении ключа обновляет значение,


иначе добавляет новую пару.


get() — только ищет и возвращает значение по ключу:


вычисляет хэш,


ищет нужный бакет,


сравнивает ключи через equals(),


возвращает найденное значение или null.


👉 Главное отличие: put() модифицирует карту, get() — только читает.

## Как решается коллизия HashMap?
Коллизия в HashMap решается с помощью связанного списка (а с Java 8 — ещё и красно-чёрного дерева).

Когда два разных ключа имеют одинаковый hashCode() и попадают в один бакет:

Элементы выстраиваются в цепочку (linked list) внутри этого бакета.

При большом числе элементов (по умолчанию ≥ 8) цепочка преобразуется в дерево, чтобы ускорить поиск с O(n) → O(log n).

Если элементов становится мало (≤ 6), дерево обратно превращается в список.

## В чем отличие Map от Set?
Map хранит пары ключ–значение, где ключи уникальны.
Set хранит только уникальные значения, без пар.

📌 Можно сказать, что Set — это частный случай Map, где хранятся только ключи без значений (в HashSet под капотом используется HashMap).

## Что такое Hashtable чем она отличается от HashMap?
Hashtable — устаревшая синхронизированная коллекция без поддержки null.
HashMap — современная, не синхронизированная, поддерживает null, работает быстрее.
Вместо Hashtable используют ConcurrentHashMap.

## Может ли null быть ключом в HashMap?
Да, в HashMap может быть один null-ключ и несколько null-значений.
В Hashtable — null не допускается.

## Какой хэш-код у null в HashMap?
У null-ключа в HashMap хэш-код считается равным 0.
Поэтому все null-ключи всегда попадают в первый бакет массива.

## Что вы знаете о коллекциях типа HashSet?
HashSet — коллекция, хранящая только уникальные элементы, без определённого порядка.
Основана на HashMap, где элементы выступают как ключи.
Операции add, remove, contains работают в среднем за O(1).
Допускает один null.
Не сохраняет порядок вставки (для этого есть LinkedHashSet).

## Как работает HashSet?
HashSet внутри использует HashMap.
Когда ты добавляешь элемент, он сохраняется как ключ в HashMap, а значение ставится фиктивное (Object PRESENT).
Алгоритм:


Вычисляется hashCode() элемента.


Определяется бакет по хэшу.


Если такого ключа нет — элемент добавляется.


Если ключ уже есть — новый не добавляется (уникальность сохраняется).


Все операции (add, remove, contains) работают в среднем за O(1).

## Что внутри Node в HashSet?
(твой ответ здесь)

## Почему в HashSet используется new Object а не null для value?
(твой ответ здесь)

## Что вы знаете о коллекциях типа LinkedHashMap?
(твой ответ здесь)

## Что вы знаете о коллекциях типа LinkedHashSet?
(твой ответ здесь)

## Что вы знаете о коллекциях типа TreeSet?
(твой ответ здесь)

## Что вы знаете о коллекциях типа TreeMap?
(твой ответ здесь)

## Как работает метод contains в ArrayList LinkedList HashSet?
(твой ответ здесь)

## Дайте определение понятию итератор?
(твой ответ здесь)

## Методы Iterator?
(твой ответ здесь)

## В чём разница между Iterator и Iterable?
(твой ответ здесь)

## В чем разница между Iterator и ListIterator?
(твой ответ здесь)

## В чем разница между Iterator и Enumeration?
(твой ответ здесь)

## В каких случаях нужно использовать iterator и почему?
(твой ответ здесь)

## Почему в классе iterator нет метода для получения следующего элемента без передвижения курсора?
(твой ответ здесь)

## Зачем в итераторе метод remove?
Метод remove() в итераторе — это ключевой инструмент для безопасного удаления элементов из коллекции во время её обхода. Если ты попытаешься удалить элемент напрямую из коллекции, пока проходишь её в цикле, это вызовет ConcurrentModificationException, потому что структура коллекции изменится неожиданно для итератора.

Используя remove() итератора, ты сообщаешь ему, что удаление происходит осознанно и контролируемо, благодаря чему итератор корректно обновляет своё внутреннее состояние. Это позволяет избежать ошибок и исключений, сохраняя целостность обхода.

Этот метод особенно полезен, когда нужно фильтровать элементы на лету — например, удалять все элементы, которые не соответствуют определённому условию, без создания дополнительного списка для удаления после итерации.
## В чём различие между fail-fast и fail-safe итераторами?
Fail-fast и fail-safe итераторы — это два разных подхода к тому, как итераторы реагируют на изменения коллекции во время обхода.

Fail-fast итераторы, которые используются в стандартных коллекциях Java (например, ArrayList, HashMap), сразу выбрасывают ConcurrentModificationException, если коллекция была изменена после создания итератора (кроме изменений через сам итератор). Это сделано для того, чтобы быстро обнаружить потенциально опасные изменения и предупредить о них, чтобы избежать непредсказуемого поведения.

Fail-safe итераторы, напротив, работают с копией коллекции или используют специальные механизмы, позволяющие безопасно обходить коллекцию, даже если она изменяется во время итерации. Например, итераторы коллекций из пакета java.util.concurrent (CopyOnWriteArrayList, ConcurrentHashMap) реализуют fail-safe поведение. Они не выбрасывают исключения при изменениях, но могут не отражать самые последние изменения в коллекции.

Главное отличие: fail-fast итераторы быстро сигнализируют об ошибках модификации, а fail-safe итераторы позволяют продолжать работу, жертвуя актуальностью данных.


## Что делать чтобы не возникло ConcurrentModificationException?
ConcurrentModificationException возникает, когда ты пытаешься изменить коллекцию во время её итерации с помощью, например, цикла foreach или итератора, без использования специальных механизмов. Чтобы этого избежать, есть несколько подходов:

Используй коллекции из пакета java.util.concurrent, например, CopyOnWriteArrayList или ConcurrentHashMap. Они созданы для безопасной работы в многопоточной среде и не выбрасывают ConcurrentModificationException при изменениях во время обхода.

Если используешь обычные коллекции, не меняй их напрямую во время итерации. Вместо этого собирай элементы для удаления или добавления в отдельный список, а после завершения обхода вноси изменения.

При необходимости удаления элементов во время итерации используй метод remove() самого итератора, а не коллекции. Например:

Iterator<Type iterator = collection.iterator();
while (iterator.hasNext()) {
    Type element = iterator.next();
    if (условие) {
        iterator.remove();
    }
}
Если работаешь в однопоточном режиме и хочешь защитить коллекцию от изменений извне, можно использовать обёртки Collections.synchronizedList или аналогичные, но помни, что это не решает проблему модификации во время итерации — для этого всё равно нужно соблюдать осторожность.
## Как реализован цикл foreach?


Как реализован цикл foreach?
Цикл foreach в Java — это синтаксический сахар, который упрощает перебор элементов коллекции или массива. По сути, под капотом он использует итератор, который последовательно проходит по элементам.

Когда ты пишешь:

for (ElementType element : collection) {
    // действия с element
}
компилятор превращает это в примерно такой код:

Iterator<ElementType iterator = collection.iterator();
while (iterator.hasNext()) {
    ElementType element = iterator.next();
    // действия с element
}
То есть foreach скрывает от тебя явное создание и использование итератора, делая код чище и удобнее.


## Что такое красно-черное дерево?
Красно-черное дерево — это разновидность сбалансированного двоичного дерева поиска, которое гарантирует, что высота дерева остаётся примерно пропорциональной логарифму количества элементов. Это важно, потому что благодаря такой балансировке операции поиска, вставки и удаления выполняются за время O(log n), что значительно эффективнее, чем в несбалансированных структурах.

Основная идея красно-черного дерева — это поддержание определённых правил, которые ограничивают, как могут располагаться «красные» и «чёрные» узлы. Например, корень всегда чёрный, красные узлы не могут идти подряд, а все пути от корня до листьев содержат одинаковое количество чёрных узлов. Эти правила помогают избежать слишком большой глубины и обеспечивают баланс.

В контексте Java, красно-черное дерево используется внутри HashMap начиная с Java 8, когда в одном бакете из-за коллизий накапливается много элементов. Вместо того чтобы хранить их в виде связного списка, который замедляет поиск, HashMap преобразует этот список в красно-черное дерево, что ускоряет операции поиска и вставки

## Когда HashMap преобразуется в красно-черное дерево

HashMap в Java преобразуется в красно-черное дерево, когда в одной "корзине" (бакте) количество элементов достигает определённого порога. Этот порог — 8 элементов. То есть, если в одном бакете из-за коллизий хешей накапливается 8 и более элементов, структура данных внутри этого бакета меняется с обычного связного списка на красно-черное дерево. Это делается для повышения производительности поиска — вместо линейного поиска по списку теперь используется сбалансированное дерево, что снижает время доступа с O(n) до O(log n).

Однако, чтобы это преобразование произошло, также должно быть выполнено условие, что общий размер HashMap (количество всех элементов) превышает 64. Если размер меньше, то даже при 8 элементах в бакете остаётся связный список.

Это оптимизация, введённая в Java 8, чтобы избежать деградации производительности HashMap при большом количестве коллизий.




