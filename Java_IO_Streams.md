# Потоки ввода-вывода в Java

## Что такое потоки ввода-вывода?  
Потоки (I/O streams) — это абстракция для работы с последовательностями данных:  
- **ввод** (Input) — чтение из источника (файл, клавиатура, массив байтов, сеть),  
- **вывод** (Output) — запись в приёмник (файл, консоль, массив байтов, сеть).  

В Java они представлены классами `InputStream`/`OutputStream` (для байтов) и `Reader`/`Writer` (для символов).

---

## Что делает метод `read()` при считывании символов?  
- Считывает **следующий байт или символ** из потока.  
- Возвращает **значение от 0 до 255** (для байтов) или **Unicode-код символа** (для Reader).  
- Если поток закончился — возвращает **-1**.  

---

## Почему метод `read()` возвращает `int`, а не `byte`?  
- Тип `byte` в Java — диапазон от -128 до 127.  
- Нужно ещё одно специальное значение, чтобы сообщить «конец потока» (`-1`).  
- Если бы возвращался `byte`, нельзя было бы отличить реальный байт `-1` от сигнала конца файла.  

Поэтому выбран тип `int` (он хранит и байт, и служебное значение `-1`).

---

## Почему метод `read()` не может возвращать `byte` при использовании его из класса `Reader`?  
`Reader` работает не с байтами, а с **символами** (Unicode).  
- Один символ может занимать больше 1 байта.  
- Поэтому метод `read()` в `Reader` возвращает `int`, чтобы вместить **кодовую точку символа** или `-1` для конца потока.  

---

## Внутренний алгоритм работы метода `read()` из класса `InputStream`  
1. Проверяет, доступен ли следующий байт.  
2. Если байт есть → возвращает его как `int` в диапазоне `0–255`.  
3. Если поток закончился → возвращает `-1`.  
4. Если источник временно недоступен (например, сеть) → блокируется, пока данные не появятся.  

---

## Как читать данные с заданной кодировкой?  
Использовать `InputStreamReader` с указанием `Charset`:  

```java
InputStream in = new FileInputStream("data.txt");
Reader reader = new InputStreamReader(in, StandardCharsets.UTF_8);
